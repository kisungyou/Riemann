pdmdl = riem.rmml(myriem, label=mylabs)
library(Riemann)
pdmdl = riem.rmml(myriem, label=mylabs)
library(Riemann)
pdgeo = riem.pdist(myriem)
pdmdl = riem.rmml(myriem, label=mylabs)
library(Riemann)
pdmdl = riem.rmml(myriem, label=mylabs)
image(pdmdl)
## DATA GENERATION
data(iris)
ndata  = 20
mydata = list()
for (i in 1:ndata){
mydata[[i]] = stats::cov(matrix(rnorm(100*4),ncol=4))
}
for (i in (ndata+1):(2*ndata)){
tmpdata = as.matrix(iris[,1:4]) + matrix(rnorm(150*4,sd=0.5),ncol=4)
mydata[[i]] = stats::cov(tmpdata)
}
myriem = wrap.spd(mydata)
mylabs = rep(c(1,2), each=ndata)
## COMPUTE GEODESIC AND RMML PAIRWISE DISTANCE
pdgeo = riem.pdist(myriem)
pdmdl = riem.rmml(myriem, label=mylabs)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(pdgeo[,(2*ndata):1], main="geodesic distance", axes=FALSE)
image(pdmdl[,(2*ndata):1], main="RMML distance", axes=FALSE)
par(opar)
library(Riemann)
help(riem.rmml)
## DATA GENERATION
data(iris)
ndata  = 20
mydata = list()
for (i in 1:ndata){
mydata[[i]] = stats::cov(matrix(rnorm(100*4),ncol=4))
}
for (i in (ndata+1):(2*ndata)){
tmpdata = as.matrix(iris[,1:4]) + matrix(rnorm(150*4,sd=0.5),ncol=4)
mydata[[i]] = stats::cov(tmpdata)
}
myriem = wrap.spd(mydata)
mylabs = rep(c(1,2), each=ndata)
## COMPUTE GEODESIC AND RMML PAIRWISE DISTANCE
pdgeo = riem.pdist(myriem)
pdmdl = riem.rmml(myriem, label=mylabs)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(pdgeo[,(2*ndata):1], main="geodesic distance", axes=FALSE)
image(pdmdl[,(2*ndata):1], main="RMML distance", axes=FALSE)
par(opar)
rm(list=ls())
library(Riemann)
help("riem.rmml")
library(Riemann)
devtools::document()
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
#  density on 2-dimensional sphere S^2 in R^3.
#-------------------------------------------------------------------
## PREPARE DATA OF 4 CLASSES
ndata  = 20
class1 = list()
class2 = list()
class3 = list()
class4 = list()
for (i in 1:ndata){
tmp = matrix(rnorm(4*3), ncol=3)
tmp = tmp/sqrt(rowSums(tmp^2))
class1[[i]] = tmp[1,]
class2[[i]] = tmp[2,]
class3[[i]] = tmp[3,]
class4[[i]] = tmp[4,]
}
obj1 = wrap.sphere(class1)
obj2 = wrap.sphere(class2)
obj3 = wrap.sphere(class3)
obj4 = wrap.sphere(class4)
## RUN THE ASYMPTOTIC TEST
riem.fanova(obj1, obj2, obj3, obj4)
## PREPARE DATA
sp.start = c(1,0)
sp.end   = c(0,1)
sp.data  = riem.sphere(rbind(sp.start, sp.end))
sp.data  = wrap.sphere(rbind(sp.start, sp.end))
library(Riemann)
## PREPARE DATA
sp.start = c(1,0)
sp.end   = c(0,1)
sp.data  = wrap.sphere(rbind(sp.start, sp.end))
## FIND THE INTERPOLATED POINT AT "t=0.25"
mid.int = riem.interp(sp.data, t=0.25, dtype="intrinsic")
mid.ext = riem.interp(sp.data, t=0.25, dtype="extrinsic")
mid.int = riem.interp(sp.data, t=0.25, geometry="intrinsic")
mid.ext = riem.interp(sp.data, t=0.25, geometry="extrinsic")
## VISUALIZE
#  Prepare Lines and Points
thetas  = seq(from=0, to=pi/2, length.out=100)
quarter = cbind(cos(thetas), sin(thetas))
pic.pts = rbind(sp.start, mid.int, mid.ext, sp.end)
pic.col = c("black","red","green","black")
mid.int = as.vector(riem.interp(sp.data, t=0.25, geometry="intrinsic"))
mid.ext = as.vector(riem.interp(sp.data, t=0.25, geometry="extrinsic"))
## VISUALIZE
#  Prepare Lines and Points
thetas  = seq(from=0, to=pi/2, length.out=100)
quarter = cbind(cos(thetas), sin(thetas))
pic.pts = rbind(sp.start, mid.int, mid.ext, sp.end)
pic.col = c("black","red","green","black")
# Draw
opar <- par(no.readonly=TRUE)
par(pty="s")
plot(quarter, main="two interpolated points",
xlab="x", ylab="y", type="l")
points(pic.pts, col=pic.col, pch=19)
text(mid.int[1]-0.1, mid.int[2], "intrinsic", col="red")
text(mid.ext[1]-0.1, mid.ext[2], "extrinsic", col="green")
par(opar)
library(Riemann)
sp.start = c(1,0)
sp.end   = c(0,1)
sp.data  = wrap.sphere(rbind(sp.start, sp.end))
## FIND THE INTERPOLATED POINT AT FOR t=0.1, 0.2, ..., 0.9.
myvect  = seq(from=0.1, to=0.9, by=0.1)
geo.int = riem.interps(sp.data, vect=myvect, geometry="intrinsic")
geo.ext = riem.interps(sp.data, vect=myvect, geometry="extrinsic")
geo.int
as.matrix(geo.int)
matrix(geo.int, ncol=2)
matrix(geo.int, ncol=2, byrow=TRUE)
myvect  = seq(from=0.1, to=0.9, by=0.1)
geo.int = riem.interps(sp.data, vect=myvect, geometry="intrinsic")
geo.ext = riem.interps(sp.data, vect=myvect, geometry="extrinsic")
geo.int = matrix(geo.int, byrow=TRUE, ncol=2) # re-arrange for plotting
geo.ext = matrix(geo.ext, byrow=TRUE, ncol=2)
## VISUALIZE
#  Prepare Lines and Points
thetas  = seq(from=0, to=pi/2, length.out=100)
quarter = cbind(cos(thetas), sin(thetas))
pts.int = rbind(sp.start, geo.int, sp.end)
pts.ext = rbind(sp.start, geo.ext, sp.end)
col.int = c("black", rep("red",9),  "black")
col.ext = c("black", rep("blue",9), "black")
# Draw
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(quarter, main="intrinsic interpolation", # intrinsic geodesic
xlab="x", ylab="y", type="l")
points(pts.int, col=col.int, pch=19)
for (i in 1:9){
text(geo.int[i,1]*0.9, geo.int[i,2]*0.9,
paste0(round(i/10,2)), col="red")
}
plot(quarter, main="extrinsic interpolation", # intrinsic geodesic
xlab="x", ylab="y", type="l")
points(pts.ext, col=col.ext, pch=19)
for (i in 1:9){
text(geo.ext[i,1]*0.9, geo.ext[i,2]*0.9,
paste0(round(i/10,2)), col="blue")
}
par(opar)
rm(list=ls())
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
#  GENERATION
dat.list = stiefel.runif(n=3, k=5, p=10, type="list")
dat.arr3 = stiefel.runif(n=3, k=5, p=10, type="array")
dat.riem = stiefel.runif(n=3, k=5, p=10, type="riemdata")
#  GENERATION
dat.list = stiefel.runif(n=3, k=5, p=10, type="list")
dat.arr3 = stiefel.runif(n=3, k=5, p=10, type="array")
dat.riem = stiefel.runif(n=3, k=5, p=10, type="riemdata")
library(Riemann)
dat.list = stiefel.runif(n=3, k=5, p=10, type="list")
dat.list = stiefel.runif(n=3, k=5, p=10, type="list")
dat.arr3 = stiefel.runif(n=3, k=5, p=10, type="array")
dat.riem = stiefel.runif(n=3, k=5, p=10, type="riemdata")
library(Riemann)
library(Riemann)
dat.list = stiefel.runif(n=3, k=5, p=10, type="list")
dat.arr3 = stiefel.runif(n=3, k=5, p=10, type="array")
dat.riem = stiefel.runif(n=3, k=5, p=10, type="riemdata")
dat.arr3
library(Riemann)
dat.list = stiefel.runif(n=3, k=5, p=10, type="list")
dat.arr3 = stiefel.runif(n=3, k=5, p=10, type="array")
dat.riem = stiefel.runif(n=3, k=5, p=10, type="riemdata")
dat.list
dat.arr3
dat.riem
library(Riemann)
myobj1 = stiefel.runif(n=100, k=2, p=4)
#  2. perturbed principal components
data(iris)
irdat = list()
for (n in 1:100){
tmpdata    = iris[1:50,1:4] + matrix(rnorm(50*4,sd=0.5),ncol=4)
irdat[[n]] = eigen(cov(tmpdata))$vectors[,1:2]
}
myobj2 = wrap.st(irdat)
myobj2 = wrap.stiefel(irdat)
## TEST
#  1. uniform data
stiefel.utest(myobj1, method="Rayleigh")
library(Riemann)
myobj2 = wrap.stiefel(irdat)
## TEST
#  1. uniform data
stiefel.utest(myobj1, method="Rayleigh")
stiefel.utest(myobj1, method="RayleighM")
#  2. concentrated data
stiefel.utest(myobj2, method="rayleIgh")   # method names are
stiefel.utest(myobj2, method="raYleiGhM")  # CASE - INSENSITIVE !
\dontrun{
#  Empirical Type 1 Error using the same setting as above.
niter   = 1000
counter = rep(0,niter)  # record p-values
for (i in 1:niter){
X = stiefel.runif(n=100, k=2, p=4)
counter[i] = ifelse(stiefel.utest(X)$p.value < 0.05, 1, 0)
if (i%%50 == 0){
print(paste0("iteration ",i,"/",niter," complete..."))
}
}
#  Print the result
print(paste0("* empirical Type 1 error for 'st.utest': ",round(sum(counter/niter),5)))
rm(list=ls())
library(Riemann)
library(Riemann)
dat.list = grassmann.runif(n=3, k=5, p=10, type="list")
dat.arr3 = grassmann.runif(n=3, k=5, p=10, type="array")
dat.riem = grassmann.runif(n=3, k=5, p=10, type="riemdata")
dat.list
dat.riem
library(Riemann)
#   Compare Bingham's original and modified versions of the test
#
# Test 1. sample uniformly from Gr(2,4)
# Test 2. use perturbed principal components from 'iris' data in R^4
#         which is concentrated around a point to reject H0.
#-------------------------------------------------------------------
## Data Generation
#  1. uniform data
myobj1 = grassmann.runif(n=100, k=2, p=4)
#  2. perturbed principal components
data(iris)
irdat = list()
for (n in 1:100){
tmpdata    = iris[1:50,1:4] + matrix(rnorm(50*4,sd=0.5),ncol=4)
irdat[[n]] = eigen(cov(tmpdata))$vectors[,1:2]
}
myobj2 = wrap.grassmann(irdat)
## Test 1 : uniform data
grassmann.utest(myobj1, method="Bing")
grassmann.utest(myobj1, method="BingM")
## Tests : iris data
grassmann.utest(myobj2, method="bINg")   # method names are
grassmann.utest(myobj2, method="BiNgM")  # CASE - INSENSITIVE !
#  Empirical Type 1 Error using the same setting as above.
niter   = 1000
counter = rep(0,niter)  # record p-values
for (i in 1:niter){
X = grassmann.runif(n=100, k=2, p=4)
counter[i] = ifelse(grassmann.utest(X)$p.value < 0.05, 1, 0)
if (i%%50 == 0){
print(paste0("iteration ",i,"/",niter," complete..."))
}
}
#  Print the result
print(paste0("* empirical Type 1 error: ",round(sum(counter/niter),5)))
niter   = 10000
counter = rep(0,niter)  # record p-values
for (i in 1:niter){
X = grassmann.runif(n=100, k=2, p=4)
counter[i] = ifelse(grassmann.utest(X)$p.value < 0.05, 1, 0)
if (i%%50 == 0){
print(paste0("iteration ",i,"/",niter," complete..."))
}
}
#  Print the result
print(paste0("* empirical Type 1 error: ",round(sum(counter/niter),5)))
rm(list=ls())
devtools::document()
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
ggmap::has_google_key()
??register_google
ggmap::ggmap_show_api_key()
ggmap::ggmap_hide_api_key()
register_google(key = "key1234", write = TRUE)
ggmap::register_google(key = "key1234", write = TRUE)
library(google_key)
library(ggmap)
register_google(key="asdfasdf")
library(Riemann)
library(Riemann)
library(Riemann)
help(wrap.spdk)
