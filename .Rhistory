mylabs = rep(c(1,2,3), each=10)
## EMBEDDING WITH MDS AND PGA
embed2mds = riem.mds(myriem, ndim=2, geometry="intrinsic")$embed
embed2pga = riem.pga(myriem, ndim=2)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2mds, main="Multidimensional Scaling",    col=mylabs, pch=19)
plot(embed2pga, main="Principal Geodesic Analysis", col=mylabs, pch=19)
par(opar)
# 10 perturbed data points near (0,0,1) on S^2 in R^3
#-------------------------------------------------------------------
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## EMBEDDING WITH MDS AND PGA
embed2mds = riem.mds(myriem, ndim=2, geometry="intrinsic")$embed
embed2pga = riem.pga(myriem, ndim=2)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2mds, main="Multidimensional Scaling",    col=mylabs, pch=19)
plot(embed2pga, main="Principal Geodesic Analysis", col=mylabs, pch=19)
par(opar)
embed2pga = riem.pga(myriem, ndim=2)
embed2pga
library(Riemann)
help(riem.pga)
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## EMBEDDING WITH MDS AND PGA
embed2mds = riem.mds(myriem, ndim=2, geometry="intrinsic")$embed
embed2pga = riem.pga(myriem, ndim=2)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2mds, main="Multidimensional Scaling",    col=mylabs, pch=19)
plot(embed2pga, main="Principal Geodesic Analysis", col=mylabs, pch=19)
par(opar)
help(riem.pga)
library(Riemann)
library(Riemann)
help(riem.pga)
## EMBEDDING WITH MDS AND PGA
embed2mds = riem.mds(myriem, ndim=2, geometry="intrinsic")$embed
embed2pga = riem.pga(myriem, ndim=2)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2mds, main="Multidimensional Scaling",    col=mylabs, pch=19)
plot(embed2pga, main="Principal Geodesic Analysis", col=mylabs, pch=19)
par(opar)
rm(list=ls())
library(Riemann)
set.seed(496)
ndata  = 10
mydata = list()
for (i in 1:ndata){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in (ndata+1):(2*ndata)){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in ((2*ndata)+1):(3*ndata)){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=ndata)
## RUN NONLINEAR MEANSHIFT FOR DIFFERENT 'h' VALUES
run1 = riem.nmshift(myriem, maxk=10, h=0.1)
run2 = riem.nmshift(myriem, maxk=10, h=1)
run3 = riem.nmshift(myriem, maxk=10, h=10)
## MDS FOR VISUALIZATION
mds2d = riem.mds(myriem, ndim=2)$embed
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(2,3), pty="s")
plot(mds2d, pch=19, main="label : h=0.1", col=run1$cluster)
plot(mds2d, pch=19, main="label : h=1",   col=run2$cluster)
plot(mds2d, pch=19, main="label : h=10",  col=run3$cluster)
image(run1$distance[,30:1], axes=FALSE, main="distance : h=0.1")
image(run2$distance[,30:1], axes=FALSE, main="distance : h=1")
image(run3$distance[,30:1], axes=FALSE, main="distance : h=10")
par(opar)
library(Riemann)
run1 = riem.nmshift(myriem, maxk=10, h=0.1)
run1
## RUN NONLINEAR MEANSHIFT FOR DIFFERENT 'h' VALUES
run1 = riem.nmshift(myriem, maxk=10, h=0.1)
run2 = riem.nmshift(myriem, maxk=10, h=1)
run3 = riem.nmshift(myriem, maxk=10, h=10)
## MDS FOR VISUALIZATION
mds2d = riem.mds(myriem, ndim=2)$embed
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(2,3), pty="s")
plot(mds2d, pch=19, main="label : h=0.1", col=run1$cluster)
plot(mds2d, pch=19, main="label : h=1",   col=run2$cluster)
plot(mds2d, pch=19, main="label : h=10",  col=run3$cluster)
image(run1$distance[,30:1], axes=FALSE, main="distance : h=0.1")
image(run2$distance[,30:1], axes=FALSE, main="distance : h=1")
image(run3$distance[,30:1], axes=FALSE, main="distance : h=10")
par(opar)
rm(list=ls())
library(Riemann)
??Rtsne
library(Riemann)
help("riem.tsne")
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic")
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## RUN THE ALGORITHM IN TWO GEOMETRIES
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic")
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=0.5)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=0.5)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int, main="intrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
plot(embed2ext, main="extrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
par(opar)
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
par(opar)
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
par(opar)
embed2int$embed
mylabs = rep(c(1,2,3), each=10)
## RUN THE ALGORITHM IN TWO GEOMETRIES
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=0.5)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=0.5)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
par(opar)
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=1)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=1)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
par(opar)
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=5)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=1)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
par(opar)
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=25)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=1)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## RUN THE ALGORITHM IN TWO GEOMETRIES
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=10)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=10)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
par(opar)
mylabs
mypx = 1
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=mypx)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=mypx)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
par(opar)
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## RUN THE ALGORITHM IN TWO GEOMETRIES
mypx = 1
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=mypx)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=mypx)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", ylim=c(-2,2), col=mylabs, pch=19)
par(opar)
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## RUN THE ALGORITHM IN TWO GEOMETRIES
mypx = 1
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=mypx)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=mypx)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", col=mylabs, pch=19)
par(opar)
mypx = 10
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=mypx)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=mypx)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", col=mylabs, pch=19)
par(opar)
## GENERATE DATA
mydata = list()
for (i in 1:20){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:40){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 41:60){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=20)
## RUN THE ALGORITHM IN TWO GEOMETRIES
mypx = 15
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=mypx)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=mypx)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", col=mylabs, pch=19)
par(opar)
mypx = 10
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=mypx)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=mypx)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", col=mylabs, pch=19)
par(opar)
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic")
mypx = 5
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=mypx)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=mypx)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic MDS", col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic MDS", col=mylabs, pch=19)
par(opar)
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=20)
## RUN THE ALGORITHM IN TWO GEOMETRIES
mypx = 5
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic", perplexity=mypx)
embed2ext = riem.tsne(myriem, ndim=2, geometry="extrinsic", perplexity=mypx)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2int$embed, main="intrinsic t-SNE", col=mylabs, pch=19)
plot(embed2ext$embed, main="extrinsic t-SNE", col=mylabs, pch=19)
par(opar)
??do.tsne
library(Riemann)
help(riem.tsne)
embed2int = riem.tsne(myriem, ndim=2, geometry="intrinsic")
library(Riemann)
help(riem.tsne)
library(Riemann)
library(Riemann)
help(sp.runif)
library(Riemann)
#-------------------------------------------------------------------
dat.list = sp.runif(n=10, p=5, type="list")
dat.matx = sp.runif(n=10, p=5, type="matrix")
dat.riem = sp.runif(n=10, p=5, type="riemdata")
library(Riemann)
dat.list = sp.runif(n=10, p=5, type="list")
dat.matx = sp.runif(n=10, p=5, type="matrix")
dat.riem = sp.runif(n=10, p=5, type="riemdata")
dat.list
dat.matx
dat.riem
library(Riemann)
help(sp.utest)
library(Riemann)
myobj = sp.runif(n=100, p=5, type="riemdata")
#  Compare 2 versions : Original vs Modified Rayleigh
sp.utest(myobj, method="rayleigh")
sp.utest(myobj, method="rayleighm")
library(Riemann)
myobj = sp.runif(n=100, p=5, type="riemdata")
#  Compare 2 versions : Original vs Modified Rayleigh
sp.utest(myobj, method="rayleigh")
sp.utest(myobj, method="rayleighm")
myobj = sp.runif(n=100, p=5, type="riemdata")
#  Compare 2 versions : Original vs Modified Rayleigh
sp.utest(myobj, method="rayleigh")
sp.utest(myobj, method="rayleighm")
myobj = sp.runif(n=100, p=5, type="riemdata")
#  Compare 2 versions : Original vs Modified Rayleigh
sp.utest(myobj, method="rayleigh")
sp.utest(myobj, method="rayleighm")
myobj = sp.runif(n=100, p=5, type="riemdata")
#  Compare 2 versions : Original vs Modified Rayleigh
sp.utest(myobj, method="rayleigh")
sp.utest(myobj, method="rayleighm")
myobj = sp.runif(n=100, p=5, type="riemdata")
#  Compare 2 versions : Original vs Modified Rayleigh
sp.utest(myobj, method="rayleigh")
sp.utest(myobj, method="rayleighm")
myobj = sp.runif(n=100, p=5, type="riemdata")
#  Compare 2 versions : Original vs Modified Rayleigh
sp.utest(myobj, method="rayleigh")
sp.utest(myobj, method="rayleighm")
#  Empirical Type 1 Error using the same setting as above.
niter   = 5000
counter = rep(0,niter)  # record p-values
for (i in 1:niter){
myobj = sp.runif(n=100, p=5, type="riemdata")
counter[i] = ifelse(sp.utest(myobj)$p.value < 0.05, 1, 0)
if (i%%50 == 0){
print(paste0("iteration ",i,"/",niter," complete..."))
}
}
#  Print the result
print(paste0("* empirical Type 1 error for 'sp.utest': ",round(sum(counter/niter),5)))
library(Riemann)
#-------------------------------------------------------------------
dat.list = sphere.runif(n=10, p=5, type="list")
dat.matx = sphere.runif(n=10, p=5, type="matrix")
dat.riem = sphere.runif(n=10, p=5, type="riemdata")
dat.riem
myobj = sphere.runif(n=100, p=5, type="riemdata")
#  Compare 2 versions : Original vs Modified Rayleigh
sphere.utest(myobj, method="rayleigh")
sphere.utest(myobj, method="rayleighm")
niter   = 5000
counter = rep(0,niter)  # record p-values
for (i in 1:niter){
myobj = sphere.runif(n=100, p=5, type="riemdata")
counter[i] = ifelse(sphere.utest(myobj)$p.value < 0.05, 1, 0)
if (i%%50 == 0){
print(paste0("iteration ",i,"/",niter," complete..."))
}
}
#  Print the result
print(paste0("* empirical Type 1 error for 'sp.utest': ",round(sum(counter/niter),5)))
pm = paste0("* empirical Type 1 error for 'sphere.utest': ",round(sum(counter/niter),5))
print(pm)
library(Riemann)
myobj = sphere.runif(n=100, p=5, type="riemdata")
#  Compare 2 versions : Original vs Modified Rayleigh
sphere.utest(myobj, method="rayleigh")
sphere.utest(myobj, method="rayleighm")
sphere.utest(myobj, method="rayleigh")
sphere.utest(myobj, method="rayleighm")
library(Riemann)
mylabel = sample(sample(1:3, 7, replace=TRUE), NA, NA)
mylabel = sample(c(sample(c(1:3), 7, replace=TRUE), NA, NA))
mylabel = as.factor(mylabel)
mylabel
idselect = (!is.na(mylabel))
idselect
mydata = list()
for (i in 1:5){mydata[[i]] = rnorm(4)}
mydata[[1]]
mydata
mydata[c(TRUE,FALSE,TRUE)]
as.matrix(iris[,1:4])
## Data Generation
data(iris)
ndata  = 20
mydata = list()
for (i in 1:ndata){
mydata[[i]] = stats::cov(matrix(rnorm(100*4),ncol=4))
}
for (i in (ndata+1):(2*ndata)){
tmpdata = as.matrix(iris[,1:4]) + matrix(rnorm(150*4,sd=0.5),ncol=4)
mydata[[i]] = stats::cov(tmpdata)
}
myriem = wrap.spd(mydata)
mylabs = rep(c(1,2), each=ndata)
myriem
pdgeo = riem.pdist(myriem)
pdgeo
pdmdl = riem.rmml(myriem, label=mylabs)
library(Riemann)
pdmdl = riem.rmml(myriem, label=mylabs)
library(Riemann)
pdgeo = riem.pdist(myriem)
pdmdl = riem.rmml(myriem, label=mylabs)
library(Riemann)
pdmdl = riem.rmml(myriem, label=mylabs)
image(pdmdl)
## DATA GENERATION
data(iris)
ndata  = 20
mydata = list()
for (i in 1:ndata){
mydata[[i]] = stats::cov(matrix(rnorm(100*4),ncol=4))
}
for (i in (ndata+1):(2*ndata)){
tmpdata = as.matrix(iris[,1:4]) + matrix(rnorm(150*4,sd=0.5),ncol=4)
mydata[[i]] = stats::cov(tmpdata)
}
myriem = wrap.spd(mydata)
mylabs = rep(c(1,2), each=ndata)
## COMPUTE GEODESIC AND RMML PAIRWISE DISTANCE
pdgeo = riem.pdist(myriem)
pdmdl = riem.rmml(myriem, label=mylabs)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(pdgeo[,(2*ndata):1], main="geodesic distance", axes=FALSE)
image(pdmdl[,(2*ndata):1], main="RMML distance", axes=FALSE)
par(opar)
library(Riemann)
help(riem.rmml)
## DATA GENERATION
data(iris)
ndata  = 20
mydata = list()
for (i in 1:ndata){
mydata[[i]] = stats::cov(matrix(rnorm(100*4),ncol=4))
}
for (i in (ndata+1):(2*ndata)){
tmpdata = as.matrix(iris[,1:4]) + matrix(rnorm(150*4,sd=0.5),ncol=4)
mydata[[i]] = stats::cov(tmpdata)
}
myriem = wrap.spd(mydata)
mylabs = rep(c(1,2), each=ndata)
## COMPUTE GEODESIC AND RMML PAIRWISE DISTANCE
pdgeo = riem.pdist(myriem)
pdmdl = riem.rmml(myriem, label=mylabs)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(pdgeo[,(2*ndata):1], main="geodesic distance", axes=FALSE)
image(pdmdl[,(2*ndata):1], main="RMML distance", axes=FALSE)
par(opar)
rm(list=ls())
library(Riemann)
help("riem.rmml")
library(Riemann)
devtools::document()
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
