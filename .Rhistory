tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## FIND CORESET OF SIZES 3, 6, 9
core1 = riem.coreset18B(myriem, M=3)
core2 = riem.coreset18B(myriem, M=6)
core3 = riem.coreset18B(myriem, M=9)
col1 = rep(1,30); col1[core1$coreid] = 2
col2 = rep(1,30); col2[core2$coreid] = 2
col3 = rep(1,30); col3[core3$coreid] = 2
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(embed2, pch=19, col=col1, main="coreset size=3")
plot(embed2, pch=19, col=col2, main="coreset size=6")
plot(embed2, pch=19, col=col3, main="coreset size=9")
par(opar)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## FIND CORESET OF SIZES 3, 6, 9
core1 = riem.coreset18B(myriem, M=3)
core2 = riem.coreset18B(myriem, M=6)
core3 = riem.coreset18B(myriem, M=9)
col1 = rep(1,30); col1[core1$coreid] = 2
col2 = rep(1,30); col2[core2$coreid] = 2
col3 = rep(1,30); col3[core3$coreid] = 2
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(embed2, pch=19, col=col1, main="coreset size=3")
plot(embed2, pch=19, col=col2, main="coreset size=6")
plot(embed2, pch=19, col=col3, main="coreset size=9")
par(opar)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## FIND CORESET OF SIZES 3, 6, 9
core1 = riem.coreset18B(myriem, M=3)
core2 = riem.coreset18B(myriem, M=6)
core3 = riem.coreset18B(myriem, M=9)
col1 = rep(1,30); col1[core1$coreid] = 2
col2 = rep(1,30); col2[core2$coreid] = 2
col3 = rep(1,30); col3[core3$coreid] = 2
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(embed2, pch=19, col=col1, main="coreset size=3")
plot(embed2, pch=19, col=col2, main="coreset size=6")
plot(embed2, pch=19, col=col3, main="coreset size=9")
par(opar)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## FIND CORESET OF SIZES 3, 6, 9
core1 = riem.coreset18B(myriem, M=3)
core2 = riem.coreset18B(myriem, M=6)
core3 = riem.coreset18B(myriem, M=9)
col1 = rep(1,30); col1[core1$coreid] = 2
col2 = rep(1,30); col2[core2$coreid] = 2
col3 = rep(1,30); col3[core3$coreid] = 2
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(embed2, pch=19, col=col1, main="coreset size=3")
plot(embed2, pch=19, col=col2, main="coreset size=6")
plot(embed2, pch=19, col=col3, main="coreset size=9")
par(opar)
library(Riemann)
pkgdown::build_site()
pkgdown::build_site()
library(Riemann)
library(Riemann)
library(Riemann)
library(usmap)
library(maps)
p <- usmap::us_map()
p
help(us_map)
df <- us_map(regions = "counties")
west_coast <- us_map(include = c("CA", "OR", "WA"))
df
west_coast
rm(list=ls())
mainpart <- usmap::us_map()
mainpart <- usmap::us_map()
p <- ggplot() + geom_polygon(data=mainpart)
p <- ggplot2::ggplot() + geom_polygon(data=mainpart)
library(ggplot2)
p <- ggplot2::ggplot() + geom_polygon(data=mainpart)
p
plot_usmap(regions="states")
data("cities")
cities
mygeo = data.frame(lon=cities$coord[,2], lat=cities$coord[,1])
data("earthquakes")
head(earthquakes)
mygeo = usmap_transform(data.frame(lon=cities$coord[,2], lat=cities$coord[,1]))
mygeo
plot_usmap(regions="states") +
geom_point(data=mygeo, aes(x=lon.1, y=lat.1))
plot_usmap(regions="states") +
geom_point(data=mygeo, aes(x=lon.1, y=lat.1), alpha=0.25)
myriem = riem.sphere(cities$cartesian)
rm(list=ls())
library(Riemann)
library(Riemann)
??use_vignette
usethis::use_vignette("Riemann-101", "Riemann 101 : A First Step")
usethis::use_package("usmap", type="Suggests")
usethis::use_package("ggplot2", type="Suggests")
help(cities)
cities$population
data(cities)
cities$population
help(riem.mean())
help(riem.mean)
library(Riemann)
intmean = as.vector(riem.mean(myriem)$mean) # vectorization for convenience
help("sphere.xyz2geo")
myriem = wrap.sphere(cities$cartesian)
intmean = as.vector(riem.mean(myriem)$mean) # vectorization for convenience
geomean = sphere.xyz2geo(intmean)           # (lat, lon) will be returned
geomean
eucmean = base::colMeans(cities$coord)
eucmean
as.double(eucmean)
# (EXTRA)
# Compute Euclidean average of Geographic Coordinates.
eucmean = as.double(base::colMeans(cities$coord))
viseuc = usmap_transform(data.frame(lat=eucmean[1], lon=eucmean[2]))
eucmean
geomean
# (EXTRA)
# Compute Euclidean average of Geographic Coordinates.
eucmean = as.double(base::colMeans(cities$coord))
# Merge two means
twomean = rbind(geomean, eucmean)
vismean = usmap_transform(data.frame(lat=twomean[,1], lon=twomean[,2], col=c("red","blue")))
twomean
cities$coord
cities$coord$longitude
??usmap_transform
vismean = usmap_transform(data.frame(lat=twomean[,1], lon=twomean[,2]))
vismean = usmap_transform(data.frame(lon=twomean[,2], lat=twomean[,1], col=c("red","blue")))
# visualize
mycities = usmap_transform(data.frame(lon=cities$coord[,2], lat=cities$coord[,1]))
myplot <- plot_usmap(regions="states") +
geom_point(data=mycities, aes(x=lon.1, y=lat.1), alpha=.5) +
geom_piont(data=vismean, aes(x=lon.1, y=lat.1, col=col))
myplot <- plot_usmap(regions="states") +
geom_point(data=mycities, aes(x=lon.1, y=lat.1), alpha=.5) +
geom_point(data=vismean, aes(x=lon.1, y=lat.1, col=col))
myplot
rm(list=ls())
??plot_usmap
cities
cities
data(cities)
cities$names
??geom_label_repel
library(Riemann)
rm(list=ls())
pkgdown::build_articles()
pkgdown::build_site()
options(rmarkdown.html_vignette.check_title = FALSE)
library(Riemann)
devtools::document()
pkgdown::build_site()
pkgdown::build_site()
library(Riemann)
pkgdown::build_site()
pkgdown::build_site()
library(Riemann)
pkgdown::build_site()
library(Riemann)
usethis::use_package("maptools", type="Suggests")
library(Riemann)
pkgdown::build_site()
rm(list=ls())
library(Riemann)
pkgdown::build_site()
library(Riemann)
pkgdown::build_site()
pkgdown::build_articles()
pkgdown::build_articles_index()
??build_articles_index
pkgdown::build_site()
pkgdown::build_site()
library(Riemann)
pkgdown::build_site()
pkgdown::build_site()
pkgdown::build_site()
library(Riemann)
library(Riemann)
pkgdown::build_site()
library(Riemann)
library(Riemann)
library(Riemann)
pkgdown::build_site()
library(Riemann)
library(Riemann)
## GENERATION
vecx  = seq(from=-0.9, to=0.9, length.out=50)
vecy1 = 0.5*cos(vecx) + rnorm(50, sd=0.05)
vecy2 = 0.5*cos(vecx) + rnorm(50, sd=0.05)
vecy3 = 0.5*sin(vecx) + rnorm(50, sd=0.05)
## WRAP AS RIEMOBJ
mat1 = cbind(vecx, vecy1, 1); mat1 = mat1/sqrt(rowSums(mat1^2))
mat2 = cbind(vecx, vecy2, 1); mat2 = mat2/sqrt(rowSums(mat2^2))
mat3 = cbind(vecx, vecy3, 1); mat3 = mat3/sqrt(rowSums(mat3^2))
rcurve1 = wrap.sphere(mat1)
rcurve2 = wrap.sphere(mat2)
rcurve3 = wrap.sphere(mat3)
## COMPUTE DISTANCES
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
## COMPUTE DISTANCES
riem.distlp(rcurve1, rcurve2, vect=vecx)
riem.distlp(rcurve1, rcurve3, vect=vecx)
## COMPUTE DISTANCES
riem.distlp(rcurve1, rcurve2, vect=vecx)
riem.distlp(rcurve1, rcurve3, vect=vecx)
## COMPUTE DISTANCES
riem.distlp(rcurve1, rcurve2, vect=vecx)
riem.distlp(rcurve1, rcurve3, vect=vecx)
## COMPUTE DISTANCES
riem.distlp(rcurve1, rcurve2, vect=vecx)
riem.distlp(rcurve1, rcurve3, vect=vecx)
## COMPUTE DISTANCES
riem.distlp(rcurve1, rcurve2, vect=vecx)
riem.distlp(rcurve1, rcurve3, vect=vecx)
## COMPUTE DISTANCES
riem.distlp(rcurve1, rcurve2, vect=vecx)
riem.distlp(rcurve1, rcurve3, vect=vecx)
## COMPUTE DISTANCES
riem.distlp(rcurve1, rcurve2, vect=vecx)
riem.distlp(rcurve1, rcurve3, vect=vecx)
## COMPUTE DISTANCES
riem.distlp(rcurve1, rcurve2, vect=vecx)
riem.distlp(rcurve1, rcurve3, vect=vecx)
## COMPUTE DISTANCES
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
library(Riemann)
## COMPUTE DISTANCES
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
devtools::load_all(".")
library(Riemann)
vecx  = seq(from=-0.9, to=0.9, length.out=50)
vecy1 = 0.5*cos(vecx) + rnorm(50, sd=0.05)
vecy2 = 0.5*cos(vecx) + rnorm(50, sd=0.05)
vecy3 = 0.5*sin(vecx) + rnorm(50, sd=0.05)
## WRAP AS RIEMOBJ
mat1 = cbind(vecx, vecy1, 1); mat1 = mat1/sqrt(rowSums(mat1^2))
mat2 = cbind(vecx, vecy2, 1); mat2 = mat2/sqrt(rowSums(mat2^2))
mat3 = cbind(vecx, vecy3, 1); mat3 = mat3/sqrt(rowSums(mat3^2))
rcurve1 = wrap.sphere(mat1)
rcurve2 = wrap.sphere(mat2)
rcurve3 = wrap.sphere(mat3)
## COMPUTE DISTANCES
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
library(Riemann)
## COMPUTE DISTANCES
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
## COMPUTE DISTANCES
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
library(Riemann)
riem.dtw(rcurve1, rcurve3)
library(Riemann)
riem.dtw(rcurve1, rcurve3)
library(Riemann)
riem.dtw(rcurve1, rcurve3)
vecx  = seq(from=-0.9, to=0.9, length.out=5)
vecy1 = 0.5*cos(vecx) + rnorm(50, sd=0.05)
vecy2 = 0.5*cos(vecx) + rnorm(50, sd=0.05)
vecy3 = 0.5*sin(vecx) + rnorm(50, sd=0.05)
## WRAP AS RIEMOBJ
mat1 = cbind(vecx, vecy1, 1); mat1 = mat1/sqrt(rowSums(mat1^2))
mat2 = cbind(vecx, vecy2, 1); mat2 = mat2/sqrt(rowSums(mat2^2))
mat3 = cbind(vecx, vecy3, 1); mat3 = mat3/sqrt(rowSums(mat3^2))
rcurve1 = wrap.sphere(mat1)
rcurve2 = wrap.sphere(mat2)
rcurve3 = wrap.sphere(mat3)
## COMPUTE DISTANCES
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
ntmp  = 5
vecx  = seq(from=-0.9, to=0.9, length.out=ntmp)
vecy1 = 0.5*cos(vecx) + rnorm(ntmp, sd=0.05)
vecy2 = 0.5*cos(vecx) + rnorm(ntmp, sd=0.05)
vecy3 = 0.5*sin(vecx) + rnorm(ntmp, sd=0.05)
## WRAP AS RIEMOBJ
mat1 = cbind(vecx, vecy1, 1); mat1 = mat1/sqrt(rowSums(mat1^2))
mat2 = cbind(vecx, vecy2, 1); mat2 = mat2/sqrt(rowSums(mat2^2))
mat3 = cbind(vecx, vecy3, 1); mat3 = mat3/sqrt(rowSums(mat3^2))
rcurve1 = wrap.sphere(mat1)
rcurve2 = wrap.sphere(mat2)
rcurve3 = wrap.sphere(mat3)
## COMPUTE DISTANCES
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
riem.dtw(rcurve1, rcurve3)
riem.dtw(rcurve1, rcurve3, win.size = 1)
riem.dtw(rcurve1, rcurve3, win.size = 2)
riem.dtw(rcurve1, rcurve3, win.size = 3)
riem.dtw(rcurve1, rcurve3, win.size = 2)
library(Riemann)
riem.dtw(rcurve1, rcurve3, win.size = 0)
riem.dtw(rcurve1, rcurve3, win.size = 1)
riem.dtw(rcurve1, rcurve3, win.size = 2)
library(Riemann)
#-------------------------------------------------------------------
## GENERATION
ntmp  = 10
vecx  = seq(from=-0.9, to=0.9, length.out=ntmp)
vecy1 = 0.5*cos(vecx) + rnorm(ntmp, sd=0.05)
vecy2 = 0.5*cos(vecx) + rnorm(ntmp, sd=0.05)
vecy3 = 0.5*sin(vecx) + rnorm(ntmp, sd=0.05)
## WRAP AS RIEMOBJ
mat1 = cbind(vecx, vecy1, 1); mat1 = mat1/sqrt(rowSums(mat1^2))
mat2 = cbind(vecx, vecy2, 1); mat2 = mat2/sqrt(rowSums(mat2^2))
mat3 = cbind(vecx, vecy3, 1); mat3 = mat3/sqrt(rowSums(mat3^2))
rcurve1 = wrap.sphere(mat1)
rcurve2 = wrap.sphere(mat2)
rcurve3 = wrap.sphere(mat3)
## COMPUTE DISTANCES
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve2, win.size = 0)
riem.dtw(rcurve1, rcurve2, win.size = 1)
riem.dtw(rcurve1, rcurve2, win.size = 2)
riem.dtw(rcurve1, rcurve2, win.size = 3)
riem.dtw(rcurve1, rcurve2, win.size = 4)
riem.dtw(rcurve1, rcurve2, win.size = 5)
riem.dtw(rcurve1, rcurve2, win.size = 6)
library(Riemann)
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
install.packages("dtw")
library(dtw)
pdmat2 = riem.pdist2(rcurve1, rcurve2)
dtw(pdmat2)
help(dtw)
alignment = help(dtw)
plot(alignment)
alignment
ds <- dtw(pdmat2)
ds$distance
riem.dtw(rcurve1, rcurve2)
plot(ds)
pdmat1 = riem.pdist2(rcurve1, rcurve2)
pdmat2 = riem.pdist2(rcurve2, rcurve1)
ds1 <- dtw(pdmat1)
ds2 <- dtw(pdmat2)
ds1$distance
ds2$distance
ds1$normalizedDistance
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve2, rcurve1)
ds1 <- dtw(pdmat1, step.pattern = symmetric1)
ds1$distance
riem.dtw(rcurve1, rcurve2)
dtw(pdmat1, step.pattern=symmetric1)$distance
dtw(pdmat1, step.pattern=symmetric2)$distance
symmetric1
symmetric2
asymmetric
aa = dtw(pdmat1, step.pattern=symmetric1)
aa$distance
aa$N
aa$M
plot(aa)
pdmat2 = riem.pdist2(rcurve1, rcurve3)
aa = dtw(pdmat2, step.pattern=symmetric1)
plot(aa)
riem.dtw(rcurve1, rcurve2)
riem.dtw(rcurve1, rcurve3)
symmetric1
symmetric2
usethis::use_package("dtw", type="Suggests")
??dtw
help(dtw)
pdmat12 = riem.pdist2(rcurve1, rcurve2)
# Show different step patterns
dtw(pdmat12, step=symmetric1)
dtw(pdmat12, step=symmetric1)$distance
dtw(pdmat12, step=symmetric2)$distance
dtw(pdmat12, step=asymmetric)$distance
rm(list=ls())
library(Riemann)
vecx = seq(from=-0.9, to=0.9, length.out=sample(10:50, 1))
vecx
clist = list()
for (i in 1:10){ # curve type 1
vecx = seq(from=-0.9, to=0.9, length.out=sample(10:50, 1))
vecy = 0.5*cos(vecx) + rnorm(length(vecx), sd=0.1)
mats = cbind(vecx, vecy, 1)
clist[[i]] = wrap.sphere(mats/sqrt(rowSums(mats^2)))
}
for (i in 1:10){ # curve type 2
vecx = seq(from=-0.9, to=0.9, length.out=sample(10:50, 1))
vecy = 0.5*sin(vecx) + rnorm(length(vecx), sd=0.1)
mats = cbind(vecx, vecy, 1)
clist[[i+10]] = wrap.sphere(mats/sqrt(rowSums(mats^2)))
}
## COMPUTE DISTANCES
output = array(0,c(20,20))
for (i in 1:19){
for (j in 2:20){
output[i,j] <- output[j,i] <- riem.dtw(clist[[i]], clist[[j]])
}
}
image(output)
## GENERATION
clist = list()
for (i in 1:10){ # curve type 1
vecx = seq(from=-0.9, to=0.9, length.out=sample(10:50, 1))
vecy = 0.5*cos(vecx) + rnorm(length(vecx), sd=0.1)
mats = cbind(vecx, vecy, 1)
clist[[i]] = wrap.sphere(mats/sqrt(rowSums(mats^2)))
}
for (i in 1:10){ # curve type 2
vecx = seq(from=-0.9, to=0.9, length.out=sample(10:50, 1))
vecy = 0.5*sin(vecx) + rnorm(length(vecx), sd=0.1)
mats = cbind(vecx, vecy, 1)
clist[[i+10]] = wrap.sphere(mats/sqrt(rowSums(mats^2)))
}
## COMPUTE DISTANCES
outint = array(0,c(20,20))
outext = array(0,c(20,20))
for (i in 1:19){
for (j in 2:20){
outint[i,j] <- outint[j,i] <- riem.dtw(clist[[i]], clist[[j]],
geometry="intrinsic")
outext[i,j] <- outext[j,i] <- riem.dtw(clist[[i]], clist[[j]],
geometry="extrinsic")
}
}
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
image(outint[,20:1], axes=FALSE, main="intrinsic DTW Distance")
image(outext[,20:1], axes=FALSE, main="extrinsic DTW Distance")
par(opar)
library(Riemann)
help(riem.dtw)
rm(list=ls())
??scNJW
library(Riemann)
library(Riemann)
pkgdown::build_site()
pkgdown::build_site()
remove.packages("T4transport", lib="~/R/x86_64-pc-linux-gnu-library/4.0")
??wasserstein
library(Riemann)
