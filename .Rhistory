plot(embed2, col=k3)
plot(embed2, col=k5)
# ## LOAD THE DATA AND WRAP AS RIEMOBJ
data(cities)
locations = cities$cartesian
embed2 = riem.mds(wrap.sphere(locations), ndim=2)$embed
## CLUSTERING
k2 = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3 = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5 = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
k2 = predict(movMF::movMF(locations, k=2), locations)
k3 = predict(movMF::movMF(locations, k=3), locations)
k5 = predict(movMF::movMF(locations, k=5), locations)
par(mfrow=c(1,3))
plot(embed2, col=k2)
plot(embed2, col=k3)
plot(embed2, col=k5)
# ## LOAD THE DATA AND WRAP AS RIEMOBJ
data(cities)
locations = cities$cartesian
embed2 = riem.mds(wrap.sphere(locations), ndim=2)$embed
## CLUSTERING
k2 = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3 = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5 = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
k2 = predict(movMF::movMF(locations, k=2), locations)
k3 = predict(movMF::movMF(locations, k=3), locations)
k5 = predict(movMF::movMF(locations, k=5), locations)
par(mfrow=c(1,3))
plot(embed2, col=k2)
plot(embed2, col=k3)
plot(embed2, col=k5)
x = list()
x[[1]] = 1
x[[2]] = 2
x[[3]] = 3
x[[4]] = 4
x[c(1,3)]
A = matrix(rnorm(4*2), ncol=2)
B = matrix(rnorm(4*2), ncol=2)
A*B
base::sum(A*B)
x = c(1,2,3,4)
diag(x)
base::diag(x)
x = abs(matrix(rnorm(10*3), ncol=3))
x
for (i in 1:10){tgt=x[i,]; x[i,] = tgt/sum(tgt)}
colSums(x)/10
sum(colSums(x)/10)
help(which.max)
xx = c(2,3,4,2,4)
which.max(xx)
library(Riemann)
library(Riemann)
data(cities)
locations = cities$cartesian
embed2 = riem.mds(wrap.sphere(locations), ndim=2)$embed
## CLUSTERING
k2 = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3 = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5 = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
rm(list=ls())
graphics.off()
library(Riemann)
data(cities)
locations = cities$cartesian
embed2 = riem.mds(wrap.sphere(locations), ndim=2)$embed
## CLUSTERING
k2 = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3 = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5 = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
library(Riemann)
data(cities)
locations = cities$cartesian
embed2 = riem.mds(wrap.sphere(locations), ndim=2)$embed
## CLUSTERING
k2 = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3 = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5 = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
library(Riemann)
data(cities)
locations = cities$cartesian
embed2 = riem.mds(wrap.sphere(locations), ndim=2)$embed
## CLUSTERING
k2 = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3 = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5 = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
par(mfrow=c(1,3))
plot(embed2, col=k2$cluster)
plot(embed2, col=k3$cluster)
plot(embed2, col=k5$cluster)
k2 = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3 = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5 = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
par(mfrow=c(1,3))
plot(embed2, col=k2$cluster)
plot(embed2, col=k3$cluster)
plot(embed2, col=k5$cluster)
library(Riemann)
data(cities)
locations = cities$cartesian
embed2 = riem.mds(wrap.sphere(locations), ndim=2)$embed
## CLUSTERING
k2 = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3 = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5 = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
par(mfrow=c(1,3))
plot(embed2, col=k2$cluster, pch=19)
plot(embed2, col=k3$cluster, pch=19)
plot(embed2, col=k5$cluster, pch=19)
library(Riemann)
locations = cities$cartesian
dim(locations)
# # ## LOAD THE DATA AND WRAP AS RIEMOBJ
data(cities)
locations = cities$cartesian
embed2    = array(0,c(60,2))
for (i in 1:60){
embed2[i,] = sphere.xyz2geo(locations[i,])
}
## CLUSTERING
k2 = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3 = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5 = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
par(mfrow=c(1,3))
plot(embed2, col=k2$cluster, pch=19)
plot(embed2, col=k3$cluster, pch=19)
plot(embed2, col=k5$cluster, pch=19)
plot(t(embed2), col=k2$cluster, pch=19)
plot(embed2, col=k2$cluster, pch=19)
embed2 = embed2%*%cbind(c(cos(pi/2), sin(pi/2)), c(sin(pi/2), -cos(pi/2)))
plot(embed2, col=k2$cluster, pch=19)
plot(embed2, col=k3$cluster, pch=19)
plot(embed2, col=k5$cluster, pch=19)
# # ## LOAD THE DATA AND WRAP AS RIEMOBJ
data(cities)
locations = cities$cartesian
embed2    = array(0,c(60,2))
for (i in 1:60){
embed2[i,] = sphere.xyz2geo(locations[i,])
}
## CLUSTERING
k2int = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3int = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5int = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
k2ext = predict(movMF::movMF(locations, k=2), locations)
k3ext = predict(movMF::movMF(locations, k=3), locations)
k5ext = predict(movMF::movMF(locations, k=5), locations)
par(mfrow=c(2,3))
plot(embed2, col=k2int$cluster, pch=19)
plot(embed2, col=k3int$cluster, pch=19)
plot(embed2, col=k5int$cluster, pch=19)
plot(embed2, col=k2ext, pch=19)
plot(embed2, col=k2ext, pch=19)
plot(embed2, col=k2ext, pch=19)
par(mfrow=c(2,3))
plot(embed2, col=k2int$cluster, pch=19)
plot(embed2, col=k3int$cluster, pch=19)
plot(embed2, col=k5int$cluster, pch=19)
plot(embed2, col=k2ext, pch=19)
plot(embed2, col=k3ext, pch=19)
plot(embed2, col=k5ext, pch=19)
par(mfrow=c(2,3))
plot(embed2, col=k2int$cluster, pch=19)
plot(embed2, col=k3int$cluster, pch=19)
plot(embed2, col=k5int$cluster, pch=19)
plot(embed2, col=k2ext, pch=19)
plot(embed2, col=k3ext, pch=19)
plot(embed2, col=k5ext, pch=19)
## CLUSTERING
k2int = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3int = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5int = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
k2ext = predict(movMF::movMF(locations, k=2), locations)
k3ext = predict(movMF::movMF(locations, k=3), locations)
k5ext = predict(movMF::movMF(locations, k=5), locations)
par(mfrow=c(2,3))
plot(embed2, col=k2int$cluster, pch=19)
plot(embed2, col=k3int$cluster, pch=19)
plot(embed2, col=k5int$cluster, pch=19)
plot(embed2, col=k2ext, pch=19)
plot(embed2, col=k3ext, pch=19)
plot(embed2, col=k5ext, pch=19)
## CLUSTERING
k2int = sphere.mixnorm(locations, k=2, same.lambda = TRUE)
k3int = sphere.mixnorm(locations, k=3, same.lambda = TRUE)
k5int = sphere.mixnorm(locations, k=5, same.lambda = TRUE)
k2ext = predict(movMF::movMF(locations, k=2), locations)
k3ext = predict(movMF::movMF(locations, k=3), locations)
k5ext = predict(movMF::movMF(locations, k=5), locations)
par(mfrow=c(2,3))
plot(embed2, col=k2int$cluster, pch=19)
plot(embed2, col=k3int$cluster, pch=19)
plot(embed2, col=k5int$cluster, pch=19)
plot(embed2, col=k2ext, pch=19)
plot(embed2, col=k3ext, pch=19)
plot(embed2, col=k5ext, pch=19)
4%5
4%%5
library(Riemann)
x=c(1,2,3)
names(x)=c("a","b","c")
x
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
# # ## LOAD THE DATA AND WRAP AS RIEMOBJ
data(cities)
locations = cities$cartesian
embed2    = array(0,c(60,2))
for (i in 1:60){
embed2[i,] = sphere.xyz2geo(locations[i,])
}
## CLUSTERING
k2int = sphere.mixnorm(locations, k=2, same.lambda = TRUE, printer=TRUE)
library(Riemann)
# ## LOAD THE DATA AND WRAP AS RIEMOBJ
data(cities)
locations = cities$cartesian
embed2    = array(0,c(60,2))
for (i in 1:60){
embed2[i,] = sphere.xyz2geo(locations[i,])
}
## CLUSTERING
k2int = sphere.mixnorm(locations, k=2, same.lambda = TRUE, printer=TRUE)
k3int = sphere.mixnorm(locations, k=3, same.lambda = TRUE, printer=TRUE)
k5int = sphere.mixnorm(locations, k=5, same.lambda = TRUE, printer=TRUE)
k2ext = predict(movMF::movMF(locations, k=2), locations)
k3ext = predict(movMF::movMF(locations, k=3), locations)
k5ext = predict(movMF::movMF(locations, k=5), locations)
par(mfrow=c(2,3))
plot(embed2, col=k2int$cluster, pch=19)
plot(embed2, col=k3int$cluster, pch=19)
plot(embed2, col=k5int$cluster, pch=19)
plot(embed2, col=k2ext, pch=19)
plot(embed2, col=k3ext, pch=19)
plot(embed2, col=k5ext, pch=19)
library(Riemann)
## LOAD THE DATA AND WRAP AS RIEMOBJ
data(cities)
locations = cities$cartesian
embed2    = array(0,c(60,2))
for (i in 1:60){
embed2[i,] = sphere.xyz2geo(locations[i,])
}
## CLUSTERING
k2int = sphere.mixnorm(locations, k=2, same.lambda = TRUE, printer=TRUE)
## CLUSTERING
k2int = sphere.mixnorm(locations, k=2, same.lambda = TRUE, printer=TRUE)
k3int = sphere.mixnorm(locations, k=3, same.lambda = TRUE, printer=TRUE)
k5int = sphere.mixnorm(locations, k=5, same.lambda = TRUE, printer=TRUE)
k2ext = predict(movMF::movMF(locations, k=2), locations)
k3ext = predict(movMF::movMF(locations, k=3), locations)
k5ext = predict(movMF::movMF(locations, k=5), locations)
par(mfrow=c(2,3))
plot(embed2, col=k2int$cluster, pch=19)
plot(embed2, col=k3int$cluster, pch=19)
plot(embed2, col=k5int$cluster, pch=19)
plot(embed2, col=k2ext, pch=19)
plot(embed2, col=k3ext, pch=19)
plot(embed2, col=k5ext, pch=19)
library(Riemann)
install.packages(c("RiemBase","T4transport","DEoptim","ggrepel"))
library(Riemann)
#-------------------------------------------------------------------
#          Example on Sphere : a dataset with two types
#
# class 1 : 20 perturbed data points near (1,0,0) on S^2 in R^3
# class 2 : 30 perturbed data points near (0,1,0) on S^2 in R^3
#-------------------------------------------------------------------
## GENERATE DATA
mydata1 = list()
mydata2 = list()
for (i in 1:20){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata1[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 1:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata2[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem1 = wrap.sphere(mydata1)
myriem2 = wrap.sphere(mydata2)
riem.test2wass(myriem1, myriem2, nperm=99, use.smooth=FALSE)
# class 2 : 30 perturbed data points near (0,1,0) on S^2 in R^3
#-------------------------------------------------------------------
## GENERATE DATA
mydata1 = list()
mydata2 = list()
for (i in 1:20){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata1[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 1:30){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata2[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem1 = wrap.sphere(mydata1)
myriem2 = wrap.sphere(mydata2)
## COMPUTE p-WASSERSTEIN DISTANCES
dist1 = riem.wasserstein(myriem1, myriem2, p=1)
dist2 = riem.wasserstein(myriem1, myriem2, p=2)
dist5 = riem.wasserstein(myriem1, myriem2, p=5)
pm1 = paste0("p=1: distance=",round(dist1$distance,5))
pm2 = paste0("p=2: distance=",round(dist2$distance,5))
pm5 = paste0("p=5: distance=",round(dist5$distance,5))
## VISUALIZE TRANSPORT PLAN AND DISTANCE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3))
image(dist1$plan, axes=FALSE, main=pm1)
image(dist2$plan, axes=FALSE, main=pm2)
image(dist5$plan, axes=FALSE, main=pm5)
par(opar)
# class 2 : 30 perturbed data points near (0,1,0) on S^2 in R^3
#-------------------------------------------------------------------
## GENERATE DATA
mydata1 = list()
mydata2 = list()
for (i in 1:20){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata1[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 1:30){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata2[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem1 = wrap.sphere(mydata1)
myriem2 = wrap.sphere(mydata2)
## COMPUTE p-WASSERSTEIN DISTANCES
dist1 = riem.wasserstein(myriem1, myriem2, p=1)
dist2 = riem.wasserstein(myriem1, myriem2, p=2)
dist5 = riem.wasserstein(myriem1, myriem2, p=5)
pm1 = paste0("p=1: distance=",round(dist1$distance,5))
pm2 = paste0("p=2: distance=",round(dist2$distance,5))
pm5 = paste0("p=5: distance=",round(dist5$distance,5))
## VISUALIZE TRANSPORT PLAN AND DISTANCE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3))
image(dist1$plan, axes=FALSE, main=pm1)
image(dist2$plan, axes=FALSE, main=pm2)
image(dist5$plan, axes=FALSE, main=pm5)
par(opar)
pm1 = paste0("p=1: dist=",round(dist1$distance,3))
pm2 = paste0("p=2: dist=",round(dist2$distance,3))
pm5 = paste0("p=5: dist=",round(dist5$distance,3))
## VISUALIZE TRANSPORT PLAN AND DISTANCE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3))
image(dist1$plan, axes=FALSE, main=pm1)
image(dist2$plan, axes=FALSE, main=pm2)
image(dist5$plan, axes=FALSE, main=pm5)
par(opar)
dist1$distance
dist2$distance
dist5$distance
round(dist1$distance, 10)
round(dist2$distance, 10)
library(Riemann)
library(Riemann)
library(Riemann)
help(T4cluster::scNJW)
help(scNJW)
library(Riemann)
help(riem.scNJW)
help(sc05Z)
library(Riemann)
data(iris)
X = as.matrix(iris[,1:4])
X = as.matrix(iris[,1:4])
DX = as.matrix(stats::dist(X))
A  = exp(-(DX^2))
A  = exp(-(DX^2))
A  = exp(-(DX^2))
Dhalf  = diag(sqrt(rowSums(A)))
Dhalf  = diag(sqrt(rowSums(A)))
data(iris)
X = as.matrix(iris[,1:4])
DX = as.matrix(stats::dist(X))
A  = exp(-(DX^2))
Dhalf  = diag(sqrt(rowSums(A)))
Dhinv  = diag(1/sqrt(rowSums(A)))
Lrw = diag(1/rowSums(A))%*%A
Lsy = Dhinv%*%A%*%Dhinv
eigen(Lrw)$values
X = as.matrix(iris[,1:4])
DX = as.matrix(stats::dist(X))
A  = exp(-(DX^2))
Dhalf  = diag(sqrt(rowSums(A)))
Dhinv  = diag(1/sqrt(rowSums(A)))
Lrw = diag(1/rowSums(A))%*%A
Lsy = Dhinv%*%A%*%Dhinv
par(mfrow=c(1,2))
plot(1:150, eigen(Lrw)$values, type="b")
plot(1:150, eigen(Lsy)$values, type="b")
Lrw2 = Lrw%*%Lrw
Lsy2 = Lsy%*%Lsy
par(mfrow=c(1,2))
plot(1:150, eigen(Lrw2)$values, type="b")
plot(1:150, eigen(Lsy2)$values, type="b")
evals = eigen(Lrw)$values
evals = eigen(Lrw)$values
niter = 100
xplot = 1:niter
yplot = rep(0,niter)
for (i in 1:niter){
tgtvec = as.vector(evals^i)
tgtvec = tgtvec/sum(tgtvec)
yplot[i] = sum(tgtvec*log(tgtvec))
}
graphics.off()
plot(xplot, yplot, "b", cex=0.9, pch=19)
yplot
yplot = rep(0,niter)
for (i in 1:niter){
tgtvec = as.vector(evals^i)
tgtvec = tgtvec/sum(tgtvec)
yplot[i] = -sum(tgtvec*log(tgtvec))
}
plot(xplot, yplot, "b", cex=0.9, pch=19)
yplot
rm(list=ls())
graphics.off()
library(Riemann)
library(Riemann)
## LOAD THE DATA AND WRAP AS RIEMOBJ
data(cities)
locations = cities$cartesian
embed2    = array(0,c(60,2))
for (i in 1:60){
embed2[i,] = sphere.xyz2geo(locations[i,])
}
## CLUSTERING
k2int = sphere.mixnorm(locations, k=2, same.lambda = TRUE, printer=TRUE)
## CLUSTERING
k2int = mixspnorm(locations, k=2, same.lambda = TRUE, printer=TRUE)
k2int$cluster
k2int$loglkd
k2int$criteria
k2int$membership
rowSums(k2int$membership)
k2int$parameters
rm(list=ls())
library(Riemann)
help("wrap.sphere")
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
help(mixspnorm)
help(wrap.sphere)
library(Riemann)
remove.packages("RcppDE")
install.packages("DEoptim")
install.packages("DEoptim")
install.packages(c("Rdimtools","T4cluster"))
install.packages(c("Rdimtools", "T4cluster"))
library(Riemann)
pkgdown::build_site()
library(Riemann)
#-------------------------------------------------------------------
#          Example on Sphere : a dataset with three types
#
# * 10 perturbed data points near (1,0,0) on S^2 in R^3
# * 10 perturbed data points near (0,1,0) on S^2 in R^3
# * 10 perturbed data points near (0,0,1) on S^2 in R^3
#-------------------------------------------------------------------
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(2,3,4), each=10)
## K-NN CONSTRUCTION WITH K=5 & K=10
knn1 = riem.knn(myriem, k=5)
knn2 = riem.knn(myriem, k=10)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,2), pty="s")
plot(embed2, pch=19, main="knn with k=4", col=mylabs)
for (i in 1:30){
for (j in 1:5){
lines(embed2[c(i,knn1$nn.idx[i,j]),])
}
}
plot(embed2, pch=19, main="knn with k=8", col=mylabs)
for (i in 1:30){
for (j in 1:10){
lines(embed2[c(i,knn2$nn.idx[i,j]),])
}
}
par(opar)
devtools::load_all(".")
help(macg)
library(Riemann)
help(macg)
help(gorilla)
library(Riemann)
library(Riemann)
