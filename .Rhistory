lon
xx
xx = cities$coord[1,]
xlat = xx[1]
xlon = xx[2]
x = cos(xlat)*cos(xlon)
y = cos(xlat)*sin(xlon)
z = sin(xlat)
lat = 180*asin(z)/pi
lon = 180*atan2(y,x)/pi
yy  = c(lat, lon)
xx
yy
x = cos(xlat)*cos(xlon)
y = cos(xlat)*sin(xlon)
z = sin(xlat)
x
y
z
x
y
z
cities$coord[1,]
cities$cartesian[1,]
z
asin(z)
asin(z)*180/pi
lat = 180*asin(z/6371)/pi
lon = 180*atan2(y,x)/pi
yy  = c(lat, lon)
xx = cities$coord[1,]
xlat = xx[1]
xlon = xx[2]
x = cos(xlat)*cos(xlon)
y = cos(xlat)*sin(xlon)
z = sin(xlat)
lat = 180*asin(z/6371)/pi
lon = 180*atan2(y,x)/pi
yy  = c(lat, lon)
xx
yy
asin(z)
xx
asin(z)*180/3
asin(z)*180/pi
x = 6371*cos(xlat)*cos(xlon)
x
xx = cities$coord[1,]
xx
xlat = as.double(xx[1])
xlab
xlat
xx = cities$coord[1,]
xlat = as.double(xx[1])
xlon = as.double(xx[2])
xlat
xlong
xlon
x = cos(xlat)*cos(xlon)
y = cos(xlat)*sin(xlon)
z = sin(xlat)
x
y
z
cities$cartesian[1,]
help(asin)
base::asin(z)
base::asin(z)*180/pi
xx
xx = cities$coord[1,]
xx
xlat = as.double(xx[1])*pi/180
xlon = as.double(xx[2])*pi/180
x = cos(xlat)*cos(xlon)
y = cos(xlat)*sin(xlon)
z = sin(xlat)
x
y
z
cities$cartesian[1,]
lat = 180*asin(z)/pi
lon = 180*atan2(y,x)/pi
yy  = c(lat, lon)
yy
xx
cities$coord
library(Riemann)
help("sphere.convert")
lat = 60
lon = 60
sphere.geo2xyz(lat, lon)
sphere.xyz2geo(sphere.geo2xyz(lat, lon))
library(Riemann)
sphere.xyz2geo(sphere.geo2xyz(lat, lon))
sphere.xyz2geo(sphere.geo2xyz(lat, lon))
library(maps)
data("us.cities")
idbig    = which(us.cities$pop >= 300000)
idremove = which(us.cities$name=="Honolulu HI")
idbig    = setdiff(idbig, idremove)
dat.long = us.cities$long[idbig]
dat.lati = us.cities$lat[idbig]
globe3d  = array(0,c(length(idbig),3))
for (i in 1:length(idbig)){
globe3d[i,] = sphere.geo2xyz(dat.lati[i], dat.long[i])
}
colnames(globe3d) = c("x","y","z")
coords = cbind(dat.long, dat.lati); colnames(coords)=c("longitude","latitude")
names  = us.cities$name[idbig]
papa   = us.cities$pop[idbig]
cities = list()
cities$names = names
cities$coord = coords
cities$cartesian = globe3d
cities$population = papa
usethis::use_data(cities, overwrite = TRUE)
# https://stackoverflow.com/questions/1185408/converting-from-longitude-latitude-to-cartesian-coordinates
library(maps)
data("us.cities")
idbig    = which(us.cities$pop >= 300000)
idremove = which(us.cities$name=="Honolulu HI")
idbig    = setdiff(idbig, idremove)
dat.long = us.cities$long[idbig]
dat.lati = us.cities$lat[idbig]
globe3d  = array(0,c(length(idbig),3))
for (i in 1:length(idbig)){
globe3d[i,] = sphere.geo2xyz(dat.lati[i], dat.long[i])
}
colnames(globe3d) = c("x","y","z")
coords = cbind(dat.lati, dat.long); colnames(coords)=c("latitude","longitude")
names  = us.cities$name[idbig]
papa   = us.cities$pop[idbig]
cities = list()
cities$names = names
cities$coord = coords
cities$cartesian = globe3d
cities$population = papa
usethis::use_data(cities, overwrite = TRUE)
rm(list=ls())
library(Riemann)
data("cities")
data("cities")
geo = cities$coord[1,]
xyz = cities$cartesian[1,]
geo
sphere.geo2xyz(geo[1], geo[2])
xyz
sphere.xyz2geo(xyz)
library(Riemann)
data("cities")
geo = cities$coord[1,]
xyz = cities$cartesian[1,]
sphere.geo2xyz(geo[1], geo[2])
yy
syz
xyz
sphere.xyz2geo(xyz)
geo
data(cities)
myriem = wrap.sphere(cities$cartesian)
## COMPUTE INTRINSIC/EXTRINSIC MEANS
intmean = as.vector(riem.mean(myriem, geometry="intrinsic")$mean)
extmean = as.vector(riem.mean(myriem, geometry="extrinsic")$mean)
coord.int = sphere.xyz2geo(intmean)
coord.ext = sphere.xyz2geo(extmean)
coord.int
plot(cities$coord, pch=19)
points(coord.int, pch=19, col="red")
head(cities$coord)
graphics.off()
plot(cities$coord, pch=19, cex=0.5, col="black")
points(coord.int[1], coord.int[2], pch=19, cex=2, col="red")
points(coord.ext[1], coord.ext[2], pch=19, cex=2, col="blue")
library(Riemann)
coord.int
coord.ext
intmean = as.vector(riem.mean(myriem, geometry="intrinsic", eps=1e-16)$mean)
extmean = as.vector(riem.mean(myriem, geometry="extrinsic")$mean)
intmean
extmean
rm(list=ls())
help(cities)
rm(list=ls())
library(Riemann)
data(cities)
cities$names[1]
cities$coord
data(cities)
## SELECT ALBUQUERQUE
geo = cities$coord[1,]
xyz = cities$cartesian[1,]
## CHECK TWO INPUT TYPES AND THEIR CONVERSIONS
sphere.geo2xyz(geo)
sphere.xyz2geo(xyz)
sphere.geo2xyz(geo[1], geo[2])
sphere.xyz2geo(xyz)
geo
xyz
library(Riemann)
library(Riemann)
library(Riemann)
library(Riemann)
pkgdown::build_site()
??sc05Z
library(Riemann)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
lab    = rep(c(1,2,3), each=10)
## CLUSTERING WITH DIFFERENT K VALUES
cl2 = riem.sc05Z(myriem, k=2)$cluster
cl3 = riem.sc05Z(myriem, k=3)$cluster
cl4 = riem.sc05Z(myriem, k=4)$cluster
## MDS FOR VISUALIZATION
mds2d = riem.mds(myriem, ndim=2)$embed
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,4), pty="s")
plot(mds2d, col=lab, pch=19, main="true label")
plot(mds2d, col=cl2, pch=19, main="riem.sc05Z: k=2")
plot(mds2d, col=cl3, pch=19, main="riem.sc05Z: k=3")
plot(mds2d, col=cl4, pch=19, main="riem.sc05Z: k=4")
par(opar)
## CLUSTERING WITH DIFFERENT K VALUES
cl2 = riem.sc05Z(myriem, k=2)$cluster
cl3 = riem.sc05Z(myriem, k=3)$cluster
cl4 = riem.sc05Z(myriem, k=4)$cluster
## MDS FOR VISUALIZATION
mds2d = riem.mds(myriem, ndim=2)$embed
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,4), pty="s")
plot(mds2d, col=lab, pch=19, main="true label")
plot(mds2d, col=cl2, pch=19, main="riem.sc05Z: k=2")
plot(mds2d, col=cl3, pch=19, main="riem.sc05Z: k=3")
plot(mds2d, col=cl4, pch=19, main="riem.sc05Z: k=4")
par(opar)
## CLUSTERING WITH DIFFERENT K VALUES
cl2 = riem.sc05Z(myriem, k=2)$cluster
cl3 = riem.sc05Z(myriem, k=3)$cluster
cl4 = riem.sc05Z(myriem, k=4)$cluster
## MDS FOR VISUALIZATION
mds2d = riem.mds(myriem, ndim=2)$embed
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,4), pty="s")
plot(mds2d, col=lab, pch=19, main="true label")
plot(mds2d, col=cl2, pch=19, main="riem.sc05Z: k=2")
plot(mds2d, col=cl3, pch=19, main="riem.sc05Z: k=3")
plot(mds2d, col=cl4, pch=19, main="riem.sc05Z: k=4")
par(opar)
## CLUSTERING WITH DIFFERENT K VALUES
cl2 = riem.sc05Z(myriem, k=2)$cluster
cl3 = riem.sc05Z(myriem, k=3)$cluster
cl4 = riem.sc05Z(myriem, k=4)$cluster
## MDS FOR VISUALIZATION
mds2d = riem.mds(myriem, ndim=2)$embed
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,4), pty="s")
plot(mds2d, col=lab, pch=19, main="true label")
plot(mds2d, col=cl2, pch=19, main="riem.sc05Z: k=2")
plot(mds2d, col=cl3, pch=19, main="riem.sc05Z: k=3")
plot(mds2d, col=cl4, pch=19, main="riem.sc05Z: k=4")
par(opar)
library(Riemann)
library(Riemann)
library(Riemann)
#-------------------------------------------------------------------
## GENERATE DATA
mydata1 = list()
mydata2 = list()
for (i in 1:20){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata1[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 1:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata2[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem1 = wrap.sphere(mydata1)
myriem2 = wrap.sphere(mydata2)
riem.test2mean(myriem1, myriem2, nperm=999)
library(Riemann)
riem.test2mean(myriem1, myriem2, nperm=999)
library(Riemann)
riem.test2mean(myriem1, myriem2, nperm=999)
library(Riemann)
riem.test2mean(myriem1, myriem2, nperm=999)
riem.test2mean(myriem1, myriem2, nperm=999)
riem.test2mean(myriem1, myriem2, nperm=999)
riem.test2mean(myriem1, myriem2, nperm=999)
riem.test2mean(myriem1, myriem2, nperm=999)
mydata1 = list()
mydata2 = list()
for (i in 1:20){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata1[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 1:20){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata2[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem1 = wrap.sphere(mydata1)
myriem2 = wrap.sphere(mydata2)
riem.test2mean(myriem1, myriem2, nperm=9999)
library(Riemann)
mydata1 = list()
mydata2 = list()
for (i in 1:20){
tgt = c(1, stats::rnorm(2, sd=0.05))
mydata1[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 1:20){
tgt = c(stats::rnorm(2, sd=0.05), 1)
mydata2[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem1 = wrap.sphere(mydata1)
myriem2 = wrap.sphere(mydata2)
riem.test2mean(myriem1, myriem2, nperm=9999)
riem.test2mean(myriem1, myriem2, nperm=9999)
riem.fanova(myriem1, myriem2)
riem.test2mean(myriem1, myriem2, nperm=9999, geometry="extrinsic")
riem.test2mean(myriem1, myriem2, nperm=9999, geometry="extrinsic")
riem.test2mean(myriem1, myriem2, nperm=9999, geometry="extrinsic")
library(Riemann)
library(Riemann)
pkgdown::build_site()
myriem
myriem$data[c(1,3,5)]
library(Riemann)
#-------------------------------------------------------------------
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## FIND CORESET OF SIZES 5, 10, 15
core1 = riem.coreset18B(myriem, M=5)
core2 = riem.coreset18B(myriem, M=10)
core3 = riem.coreset18B(myriem, M=15)
core1
core2
core3
## FIND CORESET OF SIZES 3, 6, 9
core1 = riem.coreset18B(myriem, M=3)
core2 = riem.coreset18B(myriem, M=6)
core3 = riem.coreset18B(myriem, M=9)
col1 = rep(1,30); col1[core1$coreid] = 2
col2 = rep(1,30); col2[core2$coreid] = 2
col3 = rep(1,30); col3[core3$coreid] = 2
plot(embed2, pch=19, col=col1, main="coreset size=3")
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(embed2, pch=19, col=col1, main="coreset size=3")
plot(embed2, pch=19, col=col2, main="coreset size=6")
plot(embed2, pch=19, col=col3, main="coreset size=9")
par(opar)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## FIND CORESET OF SIZES 3, 6, 9
core1 = riem.coreset18B(myriem, M=3)
core2 = riem.coreset18B(myriem, M=6)
core3 = riem.coreset18B(myriem, M=9)
col1 = rep(1,30); col1[core1$coreid] = 2
col2 = rep(1,30); col2[core2$coreid] = 2
col3 = rep(1,30); col3[core3$coreid] = 2
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(embed2, pch=19, col=col1, main="coreset size=3")
plot(embed2, pch=19, col=col2, main="coreset size=6")
plot(embed2, pch=19, col=col3, main="coreset size=9")
par(opar)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## FIND CORESET OF SIZES 3, 6, 9
core1 = riem.coreset18B(myriem, M=3)
core2 = riem.coreset18B(myriem, M=6)
core3 = riem.coreset18B(myriem, M=9)
col1 = rep(1,30); col1[core1$coreid] = 2
col2 = rep(1,30); col2[core2$coreid] = 2
col3 = rep(1,30); col3[core3$coreid] = 2
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(embed2, pch=19, col=col1, main="coreset size=3")
plot(embed2, pch=19, col=col2, main="coreset size=6")
plot(embed2, pch=19, col=col3, main="coreset size=9")
par(opar)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## FIND CORESET OF SIZES 3, 6, 9
core1 = riem.coreset18B(myriem, M=3)
core2 = riem.coreset18B(myriem, M=6)
core3 = riem.coreset18B(myriem, M=9)
col1 = rep(1,30); col1[core1$coreid] = 2
col2 = rep(1,30); col2[core2$coreid] = 2
col3 = rep(1,30); col3[core3$coreid] = 2
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(embed2, pch=19, col=col1, main="coreset size=3")
plot(embed2, pch=19, col=col2, main="coreset size=6")
plot(embed2, pch=19, col=col3, main="coreset size=9")
par(opar)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
## MDS FOR VISUALIZATION
embed2 = riem.mds(myriem, ndim=2)$embed
## FIND CORESET OF SIZES 3, 6, 9
core1 = riem.coreset18B(myriem, M=3)
core2 = riem.coreset18B(myriem, M=6)
core3 = riem.coreset18B(myriem, M=9)
col1 = rep(1,30); col1[core1$coreid] = 2
col2 = rep(1,30); col2[core2$coreid] = 2
col3 = rep(1,30); col3[core3$coreid] = 2
## VISUALIZE
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(embed2, pch=19, col=col1, main="coreset size=3")
plot(embed2, pch=19, col=col2, main="coreset size=6")
plot(embed2, pch=19, col=col3, main="coreset size=9")
par(opar)
library(Riemann)
pkgdown::build_site()
pkgdown::build_site()
library(Riemann)
library(Riemann)
