geom_tile("d")
plot(leaves)
leaves  = ggplot(data=plotter, aes(x=x,y=y)) +
geom_point(size=1.5) +
theme_bw() +
geom_tile("d")
plot(leaves)
leaves  = ggplot(data=plotter, aes(x=x,y=y)) +
geom_point(size=1.5) +
theme_bw()
plot(leaves)
leaves  = ggplot(data=plotter, aes(x=x,y=y,color=cc)) +
geom_point(size=1.5) +
theme_bw() +
ggtitle("Principal Geodesic Analysis for Passiflora Leaves")
plot(leaves)
leaves  = ggplot(data=plotter, aes(x=x,y=y,color=cc,label="Clusters")) +
geom_point(size=1.5) +
theme_bw() +
ggtitle("Principal Geodesic Analysis for Passiflora Leaves")
plot(leaves)
plotter = data.frame(x=pga2d[,1], y=pga2d[,2], cluster=passiflora$class)
leaves  = ggplot(data=plotter, aes(x=x,y=y,color=cluster)) +
geom_point(size=1.5) +
theme_bw() +
ggtitle("Principal Geodesic Analysis for Passiflora Leaves")
plot(leaves)
leaves  = ggplot(data=plotter, aes(x=x,y=y,color=cluster)) +
geom_point(size=1.5) +
theme_bw() +
ggtitle("Principal Geodesic Analysis for Passiflora Leaves") +
xlab("1")
plot(leaves)
leaves  = ggplot(data=plotter, aes(x=x,y=y,color=cluster)) +
geom_point(size=1.5) +
theme_bw() +
ggtitle("Principal Geodesic Analysis for Passiflora Leaves") +
xlab("Dimension 1") +
ylab("Dimension 2")
plot(leaves)
rm(list=ls())
library(ggplot2)
plotter = data.frame(x=pga2d[,1], y=pga2d[,2], cluster=passiflora$class)
leaves  = ggplot(data=plotter, aes(x=x,y=y,color=cluster)) +
geom_point(size=1.5) +
theme_bw() +
ggtitle("Principal Geodesic Analysis for Passiflora Leaves") +
xlab("Dimension 1") +
ylab("Dimension 2")
plot(leaves)
library(Riemann)
data(passiflora)                         # load the data
riemobj = wrap.landmark(passiflora$data) # wrap as RIEMOBJ
pga2d   = riem.pga(riemobj)$embed        # embedding via PGA
opar <- par(no.readonly=TRUE)            # visualize
plot(pga2d, col=passiflora$class, pch=19, cex=0.7,
main="PGA Embedding of Passiflora Leaves",
xlab="dimension 1", ylab="dimension 2")
par(opar)
plotter = data.frame(x=pga2d[,1], y=pga2d[,2], cluster=passiflora$class)
leaves  = ggplot(data=plotter, aes(x=x,y=y,color=cluster)) +
geom_point(size=1.5) +
theme_bw() +
ggtitle("Principal Geodesic Analysis for Passiflora Leaves") +
xlab("Dimension 1") +
ylab("Dimension 2")
plot(leaves)
rm(list=ls())
pkgdown::build_site()
data("passiflora")
riemflower = wrap.landmark(passiflora$data)
distflower = riem.pdist(riemflower, as.dist=TRUE)
fl = as.vector(distflower)
stats::var(fl)
xx = passiflora$data[[1]]
graphics.off()
plot(xx, pch=19)
xx = passiflora$data[,,1]
plot(xx, pch=19)
lines(rbind(xx, xx[1,]))
mydat = passiflora$data[,,1:3]
myriem = wrap.landmark(mydat)
riem.pdist(myriem, geometry="intrinsic")
riem.pdist(myriem, geometry="extrinsic")
test = array(0,c(3,3))
for (i in 1:3){
datx = myriem$data[[i]]
xxxx = datx%*%t(datx)
for (j in 1:3){
daty = myriem$data[[j]]
yyyy = daty%*%t(daty)
test[i,j] <- norm(xxxx-yyyy,"F")
test[j,i] <- test[i,j]
}
}
test
riem.pdist(myriem, geometry="extrinsic")
i=1
j=2
datx = myriem$data[[i]]
xnow = base::complex(real=datx[,1], imaginary = datx[,2])
daty = myriem$data[[j]]
ynow = base::complex(real=daty[,1], imaginary = daty[,2])
xnow
outer(xnow,ynow)
sum(diag(outer(xnow,ynow)))
znow = xnow-ynow
sum(znow*Conj(znow))
sum(diag(outer(znow,znow)))
sqrt(sum(diag(outer(znow,znow))))
sum(diag(outer(znow,Conj(znow))))
test = array(0,c(3,3))
for (i in 1:3){
datx = myriem$data[[i]]
xnow = base::complex(real=datx[,1], imaginary = datx[,2])
for (j in 1:3){
daty = myriem$data[[j]]
ynow = base::complex(real=daty[,1], imaginary = daty[,2])
znow = xnow-ynow
test[j,i] <- test[i,j] <- base::Re(sum(diag(outer(znow,Conj(znow))))) #== sum(znow*Conj(znow))
}
}
test
test[j,i] <- test[i,j] <- sqrt(base::Re(sum(diag(outer(znow,Conj(znow)))))) #== sum(znow*Conj(znow))
riem.pdist(myriem, geometry="intrinsic")
riem.pdist(myriem, geometry="extrinsic")
test = array(0,c(3,3))
for (i in 1:3){
datx = myriem$data[[i]]
xnow = base::complex(real=datx[,1], imaginary = datx[,2])
for (j in 1:3){
daty = myriem$data[[j]]
ynow = base::complex(real=daty[,1], imaginary = daty[,2])
znow = xnow-ynow
test[j,i] <- test[i,j] <- sqrt(base::Re(sum(diag(outer(znow,Conj(znow)))))) #== sum(znow*Conj(znow))
}
}
test
rm(list=ls9)
rm(list=ls())
library(Riemann)
devtools::document()
library(Riemann)
pkgdown::build_site()
?shortestpath
A = array(0,c(10,10))
for (i in 1:9){
A[i,i+1] = 1
A[i+1,i] = 1
}
A[10,1] <- A[1,10] <- 1
A
rm(list=ls())
library(Riemann)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mds2d = riem.mds(myriem)$embed
iso11 = riem.isomap(myriem, nnbd=5)$embed
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mds2d = riem.mds(myriem)$embed
iso11 = riem.isomap(myriem, nnbd=5)$embed
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mds2d = riem.mds(myriem)$embed
iso11 = riem.isomap(myriem, nnbd=5)$embed
iso11 = riem.isomap(myriem, nnbd=5)
library(Riemann)
iso11 = riem.isomap(myriem, nnbd=5)
iso11
any(is.infinite(distgeo))
any(is.infinite(iso11))
cmdscale(iso11)
distgeo = as.matrix(iso11)
image(distgeo)
distgeo[is.infinite(distgeo)] = 10000
Y = cmdscale(distgeo)
plot(Y)
rm(list=ls())
library(Riemann)
mds2d = riem.mds(myriem)$embed
iso11 = riem.isomap(myriem, nnbd=5)
# 10 perturbed data points near (1,0,0) on S^2 in R^3
# 10 perturbed data points near (0,1,0) on S^2 in R^3
# 10 perturbed data points near (0,0,1) on S^2 in R^3
#-------------------------------------------------------------------
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mds2d = riem.mds(myriem)$embed
iso11 = riem.isomap(myriem, nnbd=5)
library(Riemann)
iso11 = riem.isomap(myriem, nnbd=5)
iso5 = riem.isomap(myriem, nnbd=5)
plot(iso5$embed)
library(Riemann)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mdss = riem.mds(myriem)$embed
iso1 = riem.isomap(myriem, nnbd=5)$embed
iso2 = riem.isomap(myriem, nnbd=10)$embed
iso3 = riem.isomap(myriem, nnbd=20)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,4), pty="s")
plot(mdss, col=mylabs, pch=19, main="MDS")
par(opar)
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,4), pty="s")
plot(mdss, col=mylabs, pch=19, main="MDS")
plot(iso1, col=mylabs, pch=19, main="ISOMAP:nnbd=5")
plot(iso2, col=mylabs, pch=19, main="ISOMAP:nnbd=10")
plot(iso3, col=mylabs, pch=19, main="ISOMAP:nnbd=20")
par(opar)
rm(list=ls())
library(Riemann)
mdss = riem.mds(myriem)$embed
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mdss = riem.mds(myriem)$embed
iso1 = riem.isomap(myriem, nnbd=5)$embed
iso2 = riem.isomap(myriem, nnbd=10)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(mdss, col=mylabs, pch=19, main="MDS")
plot(iso1, col=mylabs, pch=19, main="ISOMAP:nnbd=5")
plot(iso2, col=mylabs, pch=19, main="ISOMAP:nnbd=10")
par(opar)
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mdss = riem.mds(myriem)$embed
iso1 = riem.isomap(myriem, nnbd=5)$embed
iso2 = riem.isomap(myriem, nnbd=10)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(mdss, col=mylabs, pch=19, main="MDS")
plot(iso1, col=mylabs, pch=19, main="ISOMAP:nnbd=5")
plot(iso2, col=mylabs, pch=19, main="ISOMAP:nnbd=10")
par(opar)
library(Riemann)
help("riem.isomap")
library(Riemann)
#-------------------------------------------------------------------
## GENERATE DATA
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mdss = riem.mds(myriem)$embed
iso1 = riem.isomap(myriem, nnbd=5)$embed
iso2 = riem.isomap(myriem, nnbd=10)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(mdss, col=mylabs, pch=19, main="MDS")
plot(iso1, col=mylabs, pch=19, main="ISOMAP:nnbd=5")
plot(iso2, col=mylabs, pch=19, main="ISOMAP:nnbd=10")
par(opar)
iso1
names(iso1)
iso1
library(Riemann)
mydata = list()
for (i in 1:10){
tgt = c(1, stats::rnorm(2, sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 11:20){
tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
for (i in 21:30){
tgt = c(stats::rnorm(2, sd=0.1), 1)
mydata[[i]] = tgt/sqrt(sum(tgt^2))
}
myriem = wrap.sphere(mydata)
mylabs = rep(c(1,2,3), each=10)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mdss = riem.mds(myriem)$embed
iso1 = riem.isomap(myriem, nnbd=5)$embed
iso2 = riem.isomap(myriem, nnbd=10)$embed
iso1
names(iso1)
iso1
library(Riemann)
iso1 = riem.isomap(myriem, nnbd=5)
names(iso1)
iso1$embed
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mdss = riem.mds(myriem)$embed
iso1 = riem.isomap(myriem, nnbd=5)$embed
iso2 = riem.isomap(myriem, nnbd=10)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(mdss, col=mylabs, pch=19, main="MDS")
plot(iso1, col=mylabs, pch=19, main="ISOMAP:nnbd=5")
plot(iso2, col=mylabs, pch=19, main="ISOMAP:nnbd=10")
par(opar)
## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE
mdss = riem.mds(myriem)$embed
iso1 = riem.isomap(myriem, nnbd=5)$embed
iso2 = riem.isomap(myriem, nnbd=10)$embed
## VISUALIZE
opar = par(no.readonly=TRUE)
par(mfrow=c(1,3), pty="s")
plot(mdss, col=mylabs, pch=19, main="MDS")
plot(iso1, col=mylabs, pch=19, main="ISOMAP:nnbd=5")
plot(iso2, col=mylabs, pch=19, main="ISOMAP:nnbd=10")
par(opar)
library(Riemann)
pkgdown::build_site()
library(Riemann)
library(Riemann)
pkgdown::build_news()
library(Riemann)
library(Riemann)
## Optimization for eigen-decomposition
#  Let's find top-3 eigenvalues
set.seed(121)                         # set seed
A = cov(matrix(rnorm(100*5), ncol=5)) # define covariance
myfunc <- function(p){                # cost function
return(sum(-diag(t(p)%*%A%*%p)))
}
#  Solve the optimization problem
Aout = stopt.SA(myfunc, size=c(5,3), n.start=40, maxiter=500)
#  Compute 3 Eigenvalues
#  1. use computed basis
abase   = Aout$solution
eig3sol = sort(diag(t(abase)%*%A%*%abase), decreasing=TRUE)
#  2. use 'eigen' function
eig3dec = sort(eigen(A)$values, decreasing=TRUE)[1:3]
#   Visualize
opar <- par(no.readonly=TRUE)
yran = c(min(min(eig3sol),min(eig3dec))*0.95,
max(max(eig3sol),max(eig3dec))*1.05)
plot(1:3, eig3sol, type="b", col="red",  pch=19, ylim=yran,
xlab="index", ylab="eigenvalue", main="compare top 3 eigenvalues")
lines(1:3, eig3dec, type="b", col="blue", pch=19)
legend(1, 1, legend=c("optimization","decomposition"), col=c("red","blue"),
lty=rep(1,2), pch=19)
par(opar)
## Optimization for eigen-decomposition
#  Let's find top-3 eigenvalues
set.seed(121)                         # set seed
A = cov(matrix(rnorm(100*5), ncol=5)) # define covariance
myfunc <- function(p){                # cost function
return(sum(-diag(t(p)%*%A%*%p)))
}
#  Solve the optimization problem
Aout = stopt.SA(myfunc, size=c(5,3), n.start=40, maxiter=500)
#  Compute 3 Eigenvalues
#  1. use computed basis
abase   = Aout$solution
eig3sol = sort(diag(t(abase)%*%A%*%abase), decreasing=TRUE)
#  2. use 'eigen' function
eig3dec = sort(eigen(A)$values, decreasing=TRUE)[1:3]
#   Visualize
opar <- par(no.readonly=TRUE)
yran = c(min(min(eig3sol),min(eig3dec))*0.95,
max(max(eig3sol),max(eig3dec))*1.05)
plot(1:3, eig3sol, type="b", col="red",  pch=19, ylim=yran,
xlab="index", ylab="eigenvalue", main="compare top 3 eigenvalues")
lines(1:3, eig3dec, type="b", col="blue", pch=19)
legend(1, 1, legend=c("optimization","decomposition"), col=c("red","blue"),
lty=rep(1,2), pch=19)
par(opar)
Aout = riem.optSA(myfunc, size=c(5,3), n.start=40, maxiter=500)
Aout = stiefel.optSA(myfunc, size=c(5,3), n.start=40, maxiter=500)
library(Riemann)
Aout = stiefel.optSA(myfunc, p=5, k=3, n.start=40, maxiter=200)
library(Riemann)
Aout = stiefel.optSA(myfunc, p=5, k=3, n.start=40, maxiter=200)
library(Riemann)
Aout = stiefel.optSA(myfunc, p=5, k=3, n.start=40, maxiter=200)
library(Riemann)
Aout = stiefel.optSA(myfunc, p=5, k=3, n.start=40, maxiter=200)
library(Riemann)
Aout = stiefel.optSA(myfunc, p=5, k=3, n.start=40, maxiter=200)
Aout
#   Visualize
opar <- par(no.readonly=TRUE)
yran = c(min(min(eig3sol),min(eig3dec))*0.95,
max(max(eig3sol),max(eig3dec))*1.05)
plot(1:3, eig3sol, type="b", col="red",  pch=19, ylim=yran,
xlab="index", ylab="eigenvalue", main="compare top 3 eigenvalues")
lines(1:3, eig3dec, type="b", col="blue", pch=19)
legend(1, 1, legend=c("optimization","decomposition"), col=c("red","blue"),
lty=rep(1,2), pch=19)
par(opar)
#  Compute 3 Eigenvalues
#  1. use computed basis
abase   = Aout$solution
eig3sol = sort(diag(t(abase)%*%A%*%abase), decreasing=TRUE)
#  2. use 'eigen' function
eig3dec = sort(eigen(A)$values, decreasing=TRUE)[1:3]
#   Visualize
opar <- par(no.readonly=TRUE)
yran = c(min(min(eig3sol),min(eig3dec))*0.95,
max(max(eig3sol),max(eig3dec))*1.05)
plot(1:3, eig3sol, type="b", col="red",  pch=19, ylim=yran,
xlab="index", ylab="eigenvalue", main="compare top 3 eigenvalues")
lines(1:3, eig3dec, type="b", col="blue", pch=19)
legend(1, 1, legend=c("optimization","decomposition"), col=c("red","blue"),
lty=rep(1,2), pch=19)
par(opar)
library(Riemann)
library(Riemann)
pkgdown::build_site()
