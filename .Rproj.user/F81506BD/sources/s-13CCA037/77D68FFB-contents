#include <RcppArmadillo.h>
#include "riemann_src.h"

using namespace Rcpp;
using namespace arma;
using namespace std;

// 1. learning_seb : smallest enclosing ball


// 1. learning_seb : smallest enclosing ball ===================================
arma::mat learning_seb_aa2013(std::string mfdname, arma::field<arma::mat> mydata, int myiter, double myeps){
  // PREPARE
  int N = mydata.n_elem;
  int p = mydata(0).n_rows;
  int k = mydata(0).n_cols;
  
  arma::vec initweight(N,fill::ones);
  arma::mat cold = riem_initialize(mfdname, mydata, initweight);
  arma::mat clog(p,k,fill::zeros);
  arma::mat cnew(p,k,fill::zeros);
  arma::mat fnow(p,k,fill::zeros);
  double    cinc = 0.0;
  arma::vec cdists(N,fill::zeros);
  
  // MAIN ITERATION
  for (int it=0; it<myiter; it++){
    // 1. compute distances and find the target
    for (int n=0; n<N; n++){
      cdists(n) = riem_dist(mfdname, cold, mydata(n));
    }
    fnow = mydata(cdists.index_max());
    // 2. compute using geodesic
    clog = riem_log(mfdname, cold, fnow);
    cnew = riem_exp(mfdname, cold, clog, (1.0/static_cast<double>(it+1)));
    // 3. Update
    cinc = arma::norm(cold-cnew, 2);
    cold = cnew;
    if (cinc < myeps){
      break;
    }
  }
  
  // RETURN
  return(cold);
}
// [[Rcpp::export]]
Rcpp::List learning_seb(std::string mfdname, Rcpp::List& data, int myiter, double myeps, std::string method){
  // PREPARE
  int N = data.size();
  arma::field<arma::mat> mydata(N);
  for (int n=0; n<N; n++){
    mydata(n) = Rcpp::as<arma::mat>(data[n]);
  }
  
  // CENTER : BRANCHING THE METHOD
  arma::mat center;
  if (method=="aa2013"){
    center = learning_seb_aa2013(mfdname, mydata, myiter, myeps);
  }
  // RADIUS : COMPUTE THE DISTANCE AND RETURN THE LARGEST
  arma::vec vec_radius(N,fill::zeros);
  for (int n=0; n<N; n++){
    vec_radius(n) = riem_dist(mfdname, center, mydata(n));
  }
  double radius = vec_radius.max();
  
  // RETURN
  Rcpp::List result;
  result["center"] = center;
  result["radius"] = radius;
  return(result);
}