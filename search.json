[{"path":"https://kisungyou.com/Riemann/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Kisung Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://kisungyou.com/Riemann/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Kisung . Author, maintainer.","code":""},{"path":"https://kisungyou.com/Riemann/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"K (2022). Riemann: Learning Data Riemannian Manifolds. R package version 0.1.4, https://kisungyou.com/Riemann/.","code":"@Manual{,   title = {Riemann: Learning with Data on Riemannian Manifolds},   author = {Kisung You},   year = {2022},   note = {R package version 0.1.4},   url = {https://kisungyou.com/Riemann/}, }"},{"path":"https://kisungyou.com/Riemann/index.html","id":"riemann-","dir":"","previous_headings":"","what":"Learning with Data on Riemannian Manifolds","title":"Learning with Data on Riemannian Manifolds","text":"Riemann R package learning data Riemannian manifolds. statistics machine learning, term manifold appears two realms; one dimensionality reduction assume low-dimensional data manifold embedded high-dimensional Euclidean space. statistics manifolds - data lie Riemannian manifolds already well aware . Riemann aims achieve latter. interested dimension reduction, please check another R package Rdimtools.","code":""},{"path":"https://kisungyou.com/Riemann/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Learning with Data on Riemannian Manifolds","text":"Option 1 : released version CRAN. Option 2 : development version GitHub.","code":"install.packages(\"Riemann\") if (!require(\"devtools\")) {   install.packages(\"devtools\") } devtools::install_github(\"kisungyou/Riemann\")"},{"path":"https://kisungyou.com/Riemann/reference/ERP.html","id":null,"dir":"Reference","previous_headings":"","what":"Data : EEG Covariances for Event-Related Potentials — ERP","title":"Data : EEG Covariances for Event-Related Potentials — ERP","text":"dataset delivers 216 covariance matrices EEG ERPs 4 different  known classes types sources. Among 60 channels, 32 channels  taken sample covariance matrix computed participant.  data taken Python library mne's  sample data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/ERP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data : EEG Covariances for Event-Related Potentials — ERP","text":"","code":"data(ERP)"},{"path":"https://kisungyou.com/Riemann/reference/ERP.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data : EEG Covariances for Event-Related Potentials — ERP","text":"named list containing covariance \\((32\\times 32\\times 216)\\) array covariance matrices. label length-\\(216\\) factor 4 different classes.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/ERP.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data : EEG Covariances for Event-Related Potentials — ERP","text":"","code":"# \\donttest{ ## LOAD THE DATA AND WRAP AS RIEMOBJ data(ERP) myriem = wrap.spd(ERP$covariance) # }"},{"path":"https://kisungyou.com/Riemann/reference/acg.html","id":null,"dir":"Reference","previous_headings":"","what":"Angular Central Gaussian Distribution — acg","title":"Angular Central Gaussian Distribution — acg","text":"hypersphere \\(\\mathcal{S}^{p-1}\\) \\(\\mathbf{R}^p\\), Angular  Central Gaussian (ACG) distribution \\(ACG_p ()\\) defined via density $$f(x\\vert ) = ||^{-1/2} (x^\\top ^{-1} x)^{-p/2}$$  respect uniform measure \\(\\mathcal{S}^{p-1}\\) \\(\\)  symmetric positive-definite matrix. Since \\(f(x\\vert ) = f(-x\\vert )\\),  can also used axial distribution real projective space, unit sphere modulo \\(\\lbrace{+1,-1\\rbrace}\\). One constraint follow  \\(f(x\\vert ) = f(x\\vert cA)\\) \\(c > 0\\) use normalized  version numerical stability restricting \\(tr()=p\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/acg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Angular Central Gaussian Distribution — acg","text":"","code":"dacg(datalist, A)  racg(n, A)  mle.acg(datalist, ...)"},{"path":"https://kisungyou.com/Riemann/reference/acg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Angular Central Gaussian Distribution — acg","text":"datalist list length-\\(p\\) unit-norm vectors. \\((p\\times p)\\) symmetric positive-definite matrix. n number samples generated. ... extra parameters computations, including maxiter maximum number iterations run (default:50). eps tolerance level stopping criterion (default: 1e-5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/acg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Angular Central Gaussian Distribution — acg","text":"dacg gives vector evaluated densities given samples. racg generates  unit-norm vectors \\(\\mathbf{R}^p\\) wrapped list. mle.acg estimates  SPD matrix \\(\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/acg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Angular Central Gaussian Distribution — acg","text":"Tyler DE (1987). “Statistical analysis angular central Gaussian distribution sphere.” Biometrika, 74(3), 579--589. ISSN 0006-3444, 1464-3510. Mardia KV, Jupp PE (eds.) (1999). Directional Statistics,  Wiley Series Probability Statistics. John Wiley \\& Sons, Inc., Hoboken, NJ, USA. ISBN 978-0-470-31697-9 978-0-471-95333-3.","code":""},{"path":"https://kisungyou.com/Riemann/reference/acg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Angular Central Gaussian Distribution — acg","text":"","code":"# ------------------------------------------------------------------- #          Example with Angular Central Gaussian Distribution # # Given a fixed A, generate samples and estimate A via ML. # ------------------------------------------------------------------- ## GENERATE AND MLE in R^5 #  Generate data Atrue = diag(5)          # true SPD matrix sam1  = racg(50,  Atrue) # random samples sam2  = racg(100, Atrue)  #  MLE Amle1 = mle.acg(sam1) Amle2 = mle.acg(sam2)  #  Visualize opar <- par(no.readonly=TRUE) par(mfrow=c(1,3), pty=\"s\") image(Atrue[,5:1], axes=FALSE, main=\"true SPD\") image(Amle1[,5:1], axes=FALSE, main=\"MLE with n=50\") image(Amle2[,5:1], axes=FALSE, main=\"MLE with n=100\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/cities.html","id":null,"dir":"Reference","previous_headings":"","what":"Data : Populated Cities in the U.S. — cities","title":"Data : Populated Cities in the U.S. — cities","text":"January 2006, 60 cities contiguous U.S. population size  larger \\(300000\\). extracted information cities data  delivered maps package. Variables coord cartesian  two identical representations locations, can mutually converted  sphere.convert.","code":""},{"path":"https://kisungyou.com/Riemann/reference/cities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data : Populated Cities in the U.S. — cities","text":"","code":"data(cities)"},{"path":"https://kisungyou.com/Riemann/reference/cities.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data : Populated Cities in the U.S. — cities","text":"named list containing names length-\\(60\\) vector city names. coord \\((60\\times 2)\\) matrix latitude longitude. cartesian \\((60\\times 3)\\) matrix cartesian coordinates unit sphere. population length-\\(60\\) vector cities' populations.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/cities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data : Populated Cities in the U.S. — cities","text":"","code":"# \\donttest{ ## LOAD THE DATA AND WRAP AS RIEMOBJ data(cities) myriem = wrap.sphere(cities$cartesian)  ## COMPUTE INTRINSIC/EXTRINSIC MEANS intmean = as.vector(riem.mean(myriem, geometry=\"intrinsic\")$mean) extmean = as.vector(riem.mean(myriem, geometry=\"extrinsic\")$mean)  ## CONVERT TO GEOGRAPHIC COORDINATES (Lat/Lon) geo.int = sphere.xyz2geo(intmean) geo.ext = sphere.xyz2geo(extmean) # }"},{"path":"https://kisungyou.com/Riemann/reference/density.html","id":null,"dir":"Reference","previous_headings":"","what":"S3 method for mixture model : evaluate density — density","title":"S3 method for mixture model : evaluate density — density","text":"Compute density fitted mixture model.","code":""},{"path":"https://kisungyou.com/Riemann/reference/density.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"S3 method for mixture model : evaluate density — density","text":"","code":"density(object, newdata)"},{"path":"https://kisungyou.com/Riemann/reference/density.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"S3 method for mixture model : evaluate density — density","text":"object fitted mixture model riemmix class. newdata data \\(n\\) objects (vectors, matrices) can wrapped one wrap.* functions Riemann package.","code":""},{"path":"https://kisungyou.com/Riemann/reference/density.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"S3 method for mixture model : evaluate density — density","text":"length-\\(n\\) vector class labels.","code":""},{"path":"https://kisungyou.com/Riemann/reference/density.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S3 method for mixture model : evaluate density — density","text":"","code":"# \\donttest{ # ---------------------------------------------------- # #            FIT A MODEL & APPLY THE METHOD # ---------------------------------------------------- # # Load the 'city' data and wrap as 'riemobj' data(cities) locations = cities$cartesian embed2    = array(0,c(60,2))  for (i in 1:60){    embed2[i,] = sphere.xyz2geo(locations[i,]) }  # Fit a model k3 = moSN(locations, k=3)  # Evaluate  newdensity = density(k3, locations) # }"},{"path":"https://kisungyou.com/Riemann/reference/gorilla.html","id":null,"dir":"Reference","previous_headings":"","what":"Data : Gorilla Skull — gorilla","title":"Data : Gorilla Skull — gorilla","text":"29 male 30 female gorillas' skull landmark data  individual represented 8-ad/landmarks 2 dimensions.  re-arranged version data shapes package.","code":""},{"path":"https://kisungyou.com/Riemann/reference/gorilla.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data : Gorilla Skull — gorilla","text":"","code":"data(gorilla)"},{"path":"https://kisungyou.com/Riemann/reference/gorilla.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data : Gorilla Skull — gorilla","text":"named list containing male 3d array size \\((8\\times 2\\times 29)\\) female 3d array size \\((8\\times 2\\times 30)\\)","code":""},{"path":"https://kisungyou.com/Riemann/reference/gorilla.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data : Gorilla Skull — gorilla","text":"Dryden IL, Mardia KV (2016). Statistical shape analysis applications R,  Wiley series probability statistics, Second edition edition. John Wiley \\& Sons, Chichester, UK ; Hoboken, NJ. ISBN 978-1-119-07251-5 978-1-119-07250-8. Reno PL, Meindl RS, McCollum MA, Lovejoy CO (2003). \"Sexual dimorphism Australopithecus afarensis similar modern humans.\" Proceedings National Academy Sciences, 100(16):9404–9409.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/gorilla.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data : Gorilla Skull — gorilla","text":"","code":"data(gorilla)                               # load the data riem.female = wrap.landmark(gorilla$female) # wrap as RIEMOBJ opar <- par(no.readonly=TRUE) for (i in 1:30){   if (i < 2){     plot(riem.female$data[[i]], cex=0.5,           xlim=c(-1,1)/2, ylim=c(-2,2)/5,          main=\"30 female gorilla skull preshapes\",          xlab=\"dimension 1\", ylab=\"dimension 2\")     lines(riem.female$data[[i]])   } else {     points(riem.female$data[[i]], cex=0.5)     lines(riem.female$data[[i]])   } }  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/grassmann.optmacg.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimation of Distribution Algorithm with MACG Distribution — grassmann.optmacg","title":"Estimation of Distribution Algorithm with MACG Distribution — grassmann.optmacg","text":"function \\(f : Gr(k,p) \\rightarrow \\mathbf{R}\\), find minimizer  attained minimum value estimation distribution algorithm  using MACG distribution.","code":""},{"path":"https://kisungyou.com/Riemann/reference/grassmann.optmacg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimation of Distribution Algorithm with MACG Distribution — grassmann.optmacg","text":"","code":"grassmann.optmacg(func, p, k, ...)"},{"path":"https://kisungyou.com/Riemann/reference/grassmann.optmacg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimation of Distribution Algorithm with MACG Distribution — grassmann.optmacg","text":"func function minimized. p dimension parameter \\(Gr(k,p)\\). k dimension parameter \\(Gr(k,p)\\). ... extra parameters including n.start number runs; algorithm executed n.start times (default: 10). maxiter maximum number iterations run (default: 100). popsize number samples generated step stochastic search (default: 100). ratio ratio \\((0,1)\\) top ratio*popsize samples chosen parameter update (default: 0.25). print.progress logical; TRUE, prints iteration (default: FALSE).","code":""},{"path":"https://kisungyou.com/Riemann/reference/grassmann.optmacg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimation of Distribution Algorithm with MACG Distribution — grassmann.optmacg","text":"named list containing: cost minimized function value. solution \\((p\\times k)\\) matrix attains cost.","code":""},{"path":"https://kisungyou.com/Riemann/reference/grassmann.optmacg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimation of Distribution Algorithm with MACG Distribution — grassmann.optmacg","text":"","code":"#------------------------------------------------------------------- #               Optimization for Eigen-Decomposition # # Given (5x5) covariance matrix S, eigendecomposition is can be  # considered as an optimization on Grassmann manifold. Here,  # we are trying to find top 3 eigenvalues and compare. #------------------------------------------------------------------- # \\donttest{ ## PREPARE A = cov(matrix(rnorm(100*5), ncol=5)) # define covariance myfunc <- function(p){                # cost function to minimize   return(sum(-diag(t(p)%*%A%*%p))) }   ## SOLVE THE OPTIMIZATION PROBLEM Aout = grassmann.optmacg(myfunc, p=5, k=3, popsize=100, n.start=30)  ## COMPUTE EIGENVALUES #  1. USE SOLUTIONS TO THE ABOVE OPTIMIZATION  abase   = Aout$solution eig3sol = sort(diag(t(abase)%*%A%*%abase), decreasing=TRUE)  #  2. USE BASIC 'EIGEN' FUNCTION eig3dec = sort(eigen(A)$values, decreasing=TRUE)[1:3]  ## VISUALIZE opar <- par(no.readonly=TRUE) yran = c(min(min(eig3sol),min(eig3dec))*0.95,          max(max(eig3sol),max(eig3dec))*1.05) plot(1:3, eig3sol, type=\"b\", col=\"red\",  pch=19, ylim=yran,      xlab=\"index\", ylab=\"eigenvalue\", main=\"compare top 3 eigenvalues\") lines(1:3, eig3dec, type=\"b\", col=\"blue\", pch=19) legend(1.55, max(yran), legend=c(\"optimization\",\"decomposition\"), col=c(\"red\",\"blue\"),        lty=rep(1,2), pch=19)  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/grassmann.runif.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Uniform Samples on Grassmann Manifold — grassmann.runif","title":"Generate Uniform Samples on Grassmann Manifold — grassmann.runif","text":"generates \\(n\\) random samples Grassmann manifold \\(Gr(k,p)\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/grassmann.runif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Uniform Samples on Grassmann Manifold — grassmann.runif","text":"","code":"grassmann.runif(n, k, p, type = c(\"list\", \"array\", \"riemdata\"))"},{"path":"https://kisungyou.com/Riemann/reference/grassmann.runif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Uniform Samples on Grassmann Manifold — grassmann.runif","text":"n number samples generated. k dimension subspace. p original dimension (ambient space). type return type; \"list\" length-\\(n\\) list \\((p\\times k)\\) basis \\(k\\)-subspaces. \"array\" \\((p\\times k\\times n)\\) 3D array whose slices \\(k\\)-subspace basis. \"riemdata\" S3 object. See wrap.grassmann details.","code":""},{"path":"https://kisungyou.com/Riemann/reference/grassmann.runif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Uniform Samples on Grassmann Manifold — grassmann.runif","text":"object one type option.","code":""},{"path":"https://kisungyou.com/Riemann/reference/grassmann.runif.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Uniform Samples on Grassmann Manifold — grassmann.runif","text":"Chikuse Y (2003). Statistics Special Manifolds, volume 174 Lecture Notes Statistics. Springer New York, New York, NY. ISBN 978-0-387-00160-9 978-0-387-21540-2.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/grassmann.runif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Uniform Samples on Grassmann Manifold — grassmann.runif","text":"","code":"#------------------------------------------------------------------- #                 Draw Samples on Grassmann Manifold  #------------------------------------------------------------------- #  Multiple Return Types with 3 Observations of 5-dim subspaces in R^10 dat.list = grassmann.runif(n=3, k=5, p=10, type=\"list\") dat.arr3 = grassmann.runif(n=3, k=5, p=10, type=\"array\") dat.riem = grassmann.runif(n=3, k=5, p=10, type=\"riemdata\")"},{"path":"https://kisungyou.com/Riemann/reference/grassmann.utest.html","id":null,"dir":"Reference","previous_headings":"","what":"Test of Uniformity on Grassmann Manifold — grassmann.utest","title":"Test of Uniformity on Grassmann Manifold — grassmann.utest","text":"Given data Grassmann manifold \\(Gr(k,p)\\), tests whether  data distributed uniformly.","code":""},{"path":"https://kisungyou.com/Riemann/reference/grassmann.utest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test of Uniformity on Grassmann Manifold — grassmann.utest","text":"","code":"grassmann.utest(grobj, method = c(\"Bing\", \"BingM\"))"},{"path":"https://kisungyou.com/Riemann/reference/grassmann.utest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test of Uniformity on Grassmann Manifold — grassmann.utest","text":"grobj S3 \"riemdata\" class Grassmann-valued data. method (case-insensitive) name test method containing \"Bing\" Bingham statistic. \"BingM\" modified Bingham statistic better order error.","code":""},{"path":"https://kisungyou.com/Riemann/reference/grassmann.utest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test of Uniformity on Grassmann Manifold — grassmann.utest","text":"(list) object S3 class htest containing: statistic test statistic. p.value \\(p\\)-value \\(H_0\\). alternative alternative hypothesis. method name test. data.name name(s) provided sample data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/grassmann.utest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Test of Uniformity on Grassmann Manifold — grassmann.utest","text":"Chikuse Y (2003). Statistics Special Manifolds, volume 174 Lecture Notes Statistics. Springer New York, New York, NY. ISBN 978-0-387-00160-9 978-0-387-21540-2. Mardia KV, Jupp PE (eds.) (1999). Directional Statistics,  Wiley Series Probability Statistics. John Wiley \\& Sons, Inc., Hoboken, NJ, USA. ISBN 978-0-470-31697-9 978-0-471-95333-3.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/grassmann.utest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test of Uniformity on Grassmann Manifold — grassmann.utest","text":"","code":"#------------------------------------------------------------------- #   Compare Bingham's original and modified versions of the test #  # Test 1. sample uniformly from Gr(2,4) # Test 2. use perturbed principal components from 'iris' data in R^4 #         which is concentrated around a point to reject H0. #------------------------------------------------------------------- ## Data Generation #  1. uniform data myobj1 = grassmann.runif(n=100, k=2, p=4)  #  2. perturbed principal components data(iris) irdat = list() for (n in 1:100){    tmpdata    = iris[1:50,1:4] + matrix(rnorm(50*4,sd=0.5),ncol=4)    irdat[[n]] = eigen(cov(tmpdata))$vectors[,1:2] } myobj2 = wrap.grassmann(irdat)  ## Test 1 : uniform data grassmann.utest(myobj1, method=\"Bing\") #>  #> \tBingham Test of Uniformity on Grassmann Manifold #>  #> data:  myobj1 #> statistic = 2.7157, p-value = 0.9745 #> alternative hypothesis: data is not uniformly distributed on Gr(2,4). #>  grassmann.utest(myobj1, method=\"BingM\") #>  #> \tModified Bingham Test of Uniformity on Grassmann Manifold #>  #> data:  myobj1 #> statistic = 2.7055, p-value = 0.9748 #> alternative hypothesis: data is not uniformly distributed on Gr(2,4). #>   ## Tests : iris data grassmann.utest(myobj2, method=\"bINg\")   # method names are  #>  #> \tBingham Test of Uniformity on Grassmann Manifold #>  #> data:  myobj2 #> statistic = 208.34, p-value < 2.2e-16 #> alternative hypothesis: data is not uniformly distributed on Gr(2,4). #>  grassmann.utest(myobj2, method=\"BiNgM\")  # CASE - INSENSITIVE ! #>  #> \tModified Bingham Test of Uniformity on Grassmann Manifold #>  #> data:  myobj2 #> statistic = 227.02, p-value < 2.2e-16 #> alternative hypothesis: data is not uniformly distributed on Gr(2,4). #>"},{"path":"https://kisungyou.com/Riemann/reference/hands.html","id":null,"dir":"Reference","previous_headings":"","what":"Data : Left Hands — hands","title":"Data : Left Hands — hands","text":"dataset contains 10 shapes 4 subjects's left hands shape represented  56 landmark points. person, first six shapes equally spaced sequence  maximally minimally spread fingures. rest arbitrarily chosen  two constraints; (1) palm face support (2) contour  contain crossins.","code":""},{"path":"https://kisungyou.com/Riemann/reference/hands.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data : Left Hands — hands","text":"","code":"data(hands)"},{"path":"https://kisungyou.com/Riemann/reference/hands.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data : Left Hands — hands","text":"named list containing data \\((56\\times 2\\times 40)\\) array landmarks 40 subjects. person length-\\(40\\) vector subject indices.","code":""},{"path":"https://kisungyou.com/Riemann/reference/hands.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data : Left Hands — hands","text":"Stegmann M, Gomez D (2002) \"Brief Introduction Statistical Shape Analysis.\" Informatics Mathematical Modelling, Technical University Denmark, DTU.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/hands.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data : Left Hands — hands","text":"","code":"# \\donttest{ ## LOAD THE DATA  data(hands)  ## VISUALIZE 6 HANDS OF PERSON 1 opar <- par(no.readonly=TRUE) par(mfrow=c(2,3)) for (i in 1:6){   xx = hands$data[,1,i]   yy = hands$data[,2,i]   plot(xx,yy,\"b\", cex=0.9) }  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/label.html","id":null,"dir":"Reference","previous_headings":"","what":"S3 method for mixture model : predict labels — label","title":"S3 method for mixture model : predict labels — label","text":"Given fitted mixture model \\(K\\) components, predict labels  observations accordingly.","code":""},{"path":"https://kisungyou.com/Riemann/reference/label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"S3 method for mixture model : predict labels — label","text":"","code":"label(object, newdata)"},{"path":"https://kisungyou.com/Riemann/reference/label.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"S3 method for mixture model : predict labels — label","text":"object fitted mixture model riemmix class. newdata data \\(n\\) objects (vectors, matrices) can wrapped one wrap.* functions Riemann package.","code":""},{"path":"https://kisungyou.com/Riemann/reference/label.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"S3 method for mixture model : predict labels — label","text":"length-\\(n\\) vector class labels.","code":""},{"path":"https://kisungyou.com/Riemann/reference/label.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S3 method for mixture model : predict labels — label","text":"","code":"# \\donttest{ # ---------------------------------------------------- # #            FIT A MODEL & APPLY THE METHOD # ---------------------------------------------------- # # Load the 'city' data and wrap as 'riemobj' data(cities) locations = cities$cartesian embed2    = array(0,c(60,2))  for (i in 1:60){    embed2[i,] = sphere.xyz2geo(locations[i,]) }  # Fit a model k3 = moSN(locations, k=3)  # Evaluate newlabel = label(k3, locations) # }"},{"path":"https://kisungyou.com/Riemann/reference/loglkd.html","id":null,"dir":"Reference","previous_headings":"","what":"S3 method for mixture model : log-likelihood — loglkd","title":"S3 method for mixture model : log-likelihood — loglkd","text":"Given fitted mixture model \\(f(x)\\) observations \\(x_1, \\ldots, x_n \\\\mathcal{M}\\), compute log-likelihood $$L = \\log \\prod_{=1}^n f(x_i) = \\sum_{=1}^n \\log f(x_i)$$.","code":""},{"path":"https://kisungyou.com/Riemann/reference/loglkd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"S3 method for mixture model : log-likelihood — loglkd","text":"","code":"loglkd(object, newdata)"},{"path":"https://kisungyou.com/Riemann/reference/loglkd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"S3 method for mixture model : log-likelihood — loglkd","text":"object fitted mixture model riemmix class. newdata data \\(n\\) objects (vectors, matrices) can wrapped one wrap.* functions Riemann package.","code":""},{"path":"https://kisungyou.com/Riemann/reference/loglkd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"S3 method for mixture model : log-likelihood — loglkd","text":"log-likelihood.","code":""},{"path":"https://kisungyou.com/Riemann/reference/loglkd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"S3 method for mixture model : log-likelihood — loglkd","text":"","code":"# \\donttest{ # ---------------------------------------------------- # #            FIT A MODEL & APPLY THE METHOD # ---------------------------------------------------- # # Load the 'city' data and wrap as 'riemobj' data(cities) locations = cities$cartesian embed2    = array(0,c(60,2))  for (i in 1:60){    embed2[i,] = sphere.xyz2geo(locations[i,]) }  # Fit a model k3 = moSN(locations, k=3)  # Evaluate newloglkd = round(loglkd(k3, locations), 3) print(paste0(\"Log-likelihood for K=3 model fit : \", newloglkd)) #> [1] \"Log-likelihood for K=3 model fit : 88.582\" # }"},{"path":"https://kisungyou.com/Riemann/reference/macg.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix Angular Central Gaussian Distribution — macg","title":"Matrix Angular Central Gaussian Distribution — macg","text":"Stiefel Grassmann manifolds \\(St(r,p)\\) \\(Gr(r,p)\\), matrix  variant ACG distribution known Matrix Angular Central Gaussian (MACG)  distribution \\(MACG_{p,r}(\\Sigma)\\) density $$f(X\\vert \\Sigma) = |\\Sigma|^{-r/2} |X^\\top \\Sigma^{-1} X|^{-p/2}$$ \\(\\Sigma\\) \\((p\\times p)\\) symmetric positive-definite matrix.  Similar vector-variate ACG case, follow convention \\(tr(\\Sigma)=p\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/macg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix Angular Central Gaussian Distribution — macg","text":"","code":"dmacg(datalist, Sigma)  rmacg(n, r, Sigma)  mle.macg(datalist, ...)"},{"path":"https://kisungyou.com/Riemann/reference/macg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix Angular Central Gaussian Distribution — macg","text":"datalist list \\((p\\times r)\\) orthonormal matrices. Sigma \\((p\\times p)\\) symmetric positive-definite matrix. n number samples generated. r number basis. ... extra parameters computations, including maxiter maximum number iterations run (default:50). eps tolerance level stopping criterion (default: 1e-5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/macg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix Angular Central Gaussian Distribution — macg","text":"dmacg gives vector evaluated densities given samples. rmacg generates   \\((p\\times r)\\) orthonormal matrices wrapped list. mle.macg estimates  SPD matrix \\(\\Sigma\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/macg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Matrix Angular Central Gaussian Distribution — macg","text":"Chikuse Y (1990). “matrix angular central Gaussian distribution.” Journal Multivariate Analysis, 33(2), 265--274. ISSN 0047259X. Mardia KV, Jupp PE (eds.) (1999). Directional Statistics,  Wiley Series Probability Statistics. John Wiley \\& Sons, Inc., Hoboken, NJ, USA. ISBN 978-0-470-31697-9 978-0-471-95333-3. Kent JT, Ganeiber , Mardia KV (2013). \"new method simulate Bingham related distributions directional data analysis applications.\" arXiv:1310.8110.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/macg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matrix Angular Central Gaussian Distribution — macg","text":"","code":"# ------------------------------------------------------------------- #          Example with Matrix Angular Central Gaussian Distribution # # Given a fixed Sigma, generate samples and estimate Sigma via ML. # ------------------------------------------------------------------- ## GENERATE AND MLE in St(2,5)/Gr(2,5) #  Generate data Strue = diag(5)                  # true SPD matrix sam1  = rmacg(n=50,  r=2, Strue) # random samples sam2  = rmacg(n=100, r=2, Strue) # random samples  #  MLE Smle1 = mle.macg(sam1) Smle2 = mle.macg(sam2)  #  Visualize opar <- par(no.readonly=TRUE) par(mfrow=c(1,3), pty=\"s\") image(Strue[,5:1], axes=FALSE, main=\"true SPD\") image(Smle1[,5:1], axes=FALSE, main=\"MLE with n=50\") image(Smle2[,5:1], axes=FALSE, main=\"MLE with n=100\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/moSL.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite Mixture of Spherical Laplace Distributions — moSL","title":"Finite Mixture of Spherical Laplace Distributions — moSL","text":"\\(n\\) observations \\((p-1)\\) sphere \\(\\mathbf{R}^p\\),  finite mixture model fitted whose components spherical Laplace distributions via following model $$f(x; \\left\\lbrace w_k, \\mu_k, \\sigma_k \\right\\rbrace_{k=1}^K) = \\sum_{k=1}^K w_k SL(x; \\mu_k, \\sigma_k)$$ parameters \\(w_k\\)'s component weights, \\(\\mu_k\\)'s component locations, \\(\\sigma_k\\)'s component scales.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite Mixture of Spherical Laplace Distributions — moSL","text":"","code":"moSL(   data,   k = 2,   same.sigma = FALSE,   variants = c(\"soft\", \"hard\", \"stochastic\"),   ... )  # S3 method for moSL loglkd(object, newdata)  # S3 method for moSL label(object, newdata)  # S3 method for moSL density(object, newdata)"},{"path":"https://kisungyou.com/Riemann/reference/moSL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite Mixture of Spherical Laplace Distributions — moSL","text":"data data vectors form either \\((n\\times p)\\) matrix length-\\(n\\) list.  See wrap.sphere descriptions supported input types. k number clusters (default: 2). .sigma logical; TRUE use scale parameter across components, FALSE otherwise. variants type class assignment methods, one \"soft\",\"hard\", \"stochastic\". ... extra parameters including maxiter maximum number iterations (default: 50). eps stopping criterion EM algorithm (default: 1e-6). printer logical; TRUE show history algorithm, FALSE otherwise. object fitted moSL model moSL function. newdata data vectors form either \\((m\\times p)\\) matrix length-\\(m\\) list.  See wrap.sphere descriptions supported input types.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite Mixture of Spherical Laplace Distributions — moSL","text":"named list S3 class riemmix containing cluster length-\\(n\\) vector class labels (\\(1:k\\)). loglkd log likelihood fitted model. criteria vector information criteria. parameters list containing proportion, location, scale. See section details. membership \\((n\\times k)\\) row-stochastic matrix membership.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSL.html","id":"parameters-of-the-fitted-model","dir":"Reference","previous_headings":"","what":"Parameters of the fitted model","title":"Finite Mixture of Spherical Laplace Distributions — moSL","text":"fitted model characterized three parameters. \\(k\\)-mixture model \\((p-1)\\)  sphere \\(\\mathbf{R}^p\\), (1) proportion length-\\(k\\) vector component weight  sums 1, (2) location \\((k\\times p)\\) matrix whose rows per-cluster locations,  (3) concentration length-\\(k\\) vector scale parameters component.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSL.html","id":"note-on-s-methods","dir":"Reference","previous_headings":"","what":"Note on S3 methods","title":"Finite Mixture of Spherical Laplace Distributions — moSL","text":"three S3 methods; loglkd, label, density. Given random sample  size \\(m\\) newdata, (1) loglkd returns scalar value computed log-likelihood,  (2) label returns length-\\(m\\) vector cluster assignments, (3) density  evaluates densities every observation according ot model fit.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSL.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite Mixture of Spherical Laplace Distributions — moSL","text":"","code":"# \\donttest{ # ---------------------------------------------------- # #                 FITTING THE MODEL # ---------------------------------------------------- # # Load the 'city' data and wrap as 'riemobj' data(cities) locations = cities$cartesian embed2    = array(0,c(60,2))  for (i in 1:60){    embed2[i,] = sphere.xyz2geo(locations[i,]) }  # Fit the model with different numbers of clusters k2 = moSL(locations, k=2) k3 = moSL(locations, k=3) k4 = moSL(locations, k=4)  # Visualize opar <- par(no.readonly=TRUE) par(mfrow=c(1,3)) plot(embed2, col=k2$cluster, pch=19, main=\"K=2\") plot(embed2, col=k3$cluster, pch=19, main=\"K=3\") plot(embed2, col=k4$cluster, pch=19, main=\"K=4\")  par(opar)  # ---------------------------------------------------- # #                   USE S3 METHODS # ---------------------------------------------------- # # Use the same 'locations' data as new data  # (1) log-likelihood newloglkd = round(loglkd(k3, locations), 5) fitloglkd = round(k3$loglkd, 5) print(paste0(\"Log-likelihood for K=3 fitted    : \", fitloglkd)) #> [1] \"Log-likelihood for K=3 fitted    : 89.23077\" print(paste0(\"Log-likelihood for K=3 predicted : \", newloglkd)) #> [1] \"Log-likelihood for K=3 predicted : 89.23077\"  # (2) label newlabel = label(k3, locations)  # (3) density newdensity = density(k3, locations) # }"},{"path":"https://kisungyou.com/Riemann/reference/moSN.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite Mixture of Spherical Normal Distributions — moSN","title":"Finite Mixture of Spherical Normal Distributions — moSN","text":"\\(n\\) observations \\((p-1)\\) sphere \\(\\mathbf{R}^p\\),  finite mixture model fitted whose components spherical normal distributions via following model $$f(x; \\left\\lbrace w_k, \\mu_k, \\lambda_k \\right\\rbrace_{k=1}^K) = \\sum_{k=1}^K w_k SN(x; \\mu_k, \\lambda_k)$$ parameters \\(w_k\\)'s component weights, \\(\\mu_k\\)'s component locations, \\(\\lambda_k\\)'s component concentrations.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite Mixture of Spherical Normal Distributions — moSN","text":"","code":"moSN(   data,   k = 2,   same.lambda = FALSE,   variants = c(\"soft\", \"hard\", \"stochastic\"),   ... )  # S3 method for moSN loglkd(object, newdata)  # S3 method for moSN label(object, newdata)  # S3 method for moSN density(object, newdata)"},{"path":"https://kisungyou.com/Riemann/reference/moSN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite Mixture of Spherical Normal Distributions — moSN","text":"data data vectors form either \\((n\\times p)\\) matrix length-\\(n\\) list.  See wrap.sphere descriptions supported input types. k number clusters (default: 2). .lambda logical; TRUE use concentration parameter across components, FALSE otherwise. variants type class assignment methods, one \"soft\",\"hard\", \"stochastic\". ... extra parameters including maxiter maximum number iterations (default: 50). eps stopping criterion EM algorithm (default: 1e-6). printer logical; TRUE show history algorithm, FALSE otherwise. object fitted moSN model moSN function. newdata data vectors form either \\((m\\times p)\\) matrix length-\\(m\\) list.  See wrap.sphere descriptions supported input types.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite Mixture of Spherical Normal Distributions — moSN","text":"named list S3 class riemmix containing cluster length-\\(n\\) vector class labels (\\(1:k\\)). loglkd log likelihood fitted model. criteria vector information criteria. parameters list containing proportion, center, concentration. See section details. membership \\((n\\times k)\\) row-stochastic matrix membership.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSN.html","id":"parameters-of-the-fitted-model","dir":"Reference","previous_headings":"","what":"Parameters of the fitted model","title":"Finite Mixture of Spherical Normal Distributions — moSN","text":"fitted model characterized three parameters. \\(k\\)-mixture model \\((p-1)\\)  sphere \\(\\mathbf{R}^p\\), (1) proportion length-\\(k\\) vector component weight  sums 1, (2) center \\((k\\times p)\\) matrix whose rows cluster centers,  (3) concentration length-\\(k\\) vector concentration parameters component.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSN.html","id":"note-on-s-methods","dir":"Reference","previous_headings":"","what":"Note on S3 methods","title":"Finite Mixture of Spherical Normal Distributions — moSN","text":"three S3 methods; loglkd, label, density. Given random sample  size \\(m\\) newdata, (1) loglkd returns scalar value computed log-likelihood,  (2) label returns length-\\(m\\) vector cluster assignments, (3) density  evaluates densities every observation according ot model fit.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSN.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Finite Mixture of Spherical Normal Distributions — moSN","text":"K, Suh C (2022). “Parameter Estimation Model-Based Clustering Spherical Normal Distribution Unit Hypersphere.” Computational Statistics \\& Data Analysis, 107457. ISSN 01679473.","code":""},{"path":"https://kisungyou.com/Riemann/reference/moSN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite Mixture of Spherical Normal Distributions — moSN","text":"","code":"# \\donttest{ # ---------------------------------------------------- # #                 FITTING THE MODEL # ---------------------------------------------------- # # Load the 'city' data and wrap as 'riemobj' data(cities) locations = cities$cartesian embed2    = array(0,c(60,2))  for (i in 1:60){    embed2[i,] = sphere.xyz2geo(locations[i,]) }  # Fit the model with different numbers of clusters k2 = moSN(locations, k=2) k3 = moSN(locations, k=3) k4 = moSN(locations, k=4)  # Visualize opar <- par(no.readonly=TRUE) par(mfrow=c(1,3)) plot(embed2, col=k2$cluster, pch=19, main=\"K=2\") plot(embed2, col=k3$cluster, pch=19, main=\"K=3\") plot(embed2, col=k4$cluster, pch=19, main=\"K=4\")  par(opar)  # ---------------------------------------------------- # #                   USE S3 METHODS # ---------------------------------------------------- # # Use the same 'locations' data as new data  # (1) log-likelihood newloglkd = round(loglkd(k3, locations), 3) print(paste0(\"Log-likelihood for K=3 model fit : \", newloglkd)) #> [1] \"Log-likelihood for K=3 model fit : 88.582\"  # (2) label newlabel = label(k3, locations)  # (3) density newdensity = density(k3, locations) # }"},{"path":"https://kisungyou.com/Riemann/reference/orbital.html","id":null,"dir":"Reference","previous_headings":"","what":"Data : Normal Vectors to the Orbital Planes of the 9 Planets — orbital","title":"Data : Normal Vectors to the Orbital Planes of the 9 Planets — orbital","text":"9 planets solar system evolving sun via orbits.  data provides normal vector orbital planes. Normal vectors  unit-norm vectors, thought reside 2-dimensional sphere.","code":""},{"path":"https://kisungyou.com/Riemann/reference/orbital.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data : Normal Vectors to the Orbital Planes of the 9 Planets — orbital","text":"","code":"data(orbital)"},{"path":"https://kisungyou.com/Riemann/reference/orbital.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data : Normal Vectors to the Orbital Planes of the 9 Planets — orbital","text":"\\((9\\times 3)\\) matrix row normal vector planet.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/orbital.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data : Normal Vectors to the Orbital Planes of the 9 Planets — orbital","text":"","code":"## LOAD THE DATA AND WRAP AS RIEMOBJ data(orbital) myorb = wrap.sphere(orbital)  ## VISUALIZE mds2d = riem.mds(myorb)$embed opar <- par(no.readonly=TRUE) plot(mds2d, main=\"9 Planets\", pch=19, xlab=\"x\", ylab=\"y\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/passiflora.html","id":null,"dir":"Reference","previous_headings":"","what":"Data : Passiflora Leaves — passiflora","title":"Data : Passiflora Leaves — passiflora","text":"Passiflora genus 550 species flowering plants. dataset contains  15 landmarks 2 dimension 3319 leaves 40 species. Papers listed  reference section analyzed data found 7 clusters.","code":""},{"path":"https://kisungyou.com/Riemann/reference/passiflora.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data : Passiflora Leaves — passiflora","text":"","code":"data(passiflora)"},{"path":"https://kisungyou.com/Riemann/reference/passiflora.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data : Passiflora Leaves — passiflora","text":"named list containing data 3d array size \\((15\\times 2\\times 3319)\\). species length-\\(3319\\) vector 40 species factors. class length-\\(3319\\) vector 7 cluster factors.","code":""},{"path":"https://kisungyou.com/Riemann/reference/passiflora.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data : Passiflora Leaves — passiflora","text":"Chitwood DH, Otoni WC (2017). “Divergent leaf shapes among Passiflora species arise shared juvenile morphology.” Plant Direct, 1(5), e00028. ISSN 24754455. Chitwood DH, Otoni WC (2017). “Morphometric analysis Passiflora leaves: relationship landmarks vasculature elliptical Fourier descriptors blade.” GigaScience, 6(1). ISSN 2047-217X.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/passiflora.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data : Passiflora Leaves — passiflora","text":"","code":"data(passiflora)                         # load the data riemobj = wrap.landmark(passiflora$data) # wrap as RIEMOBJ pga2d   = riem.pga(riemobj)$embed        # embedding via PGA  opar <- par(no.readonly=TRUE)            # visualize plot(pga2d, col=passiflora$class, pch=19, cex=0.7,      main=\"PGA Embedding of Passiflora Leaves\",      xlab=\"dimension 1\", ylab=\"dimension 2\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/predict.m2skreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction for Manifold-to-Scalar Kernel Regression — predict.m2skreg","title":"Prediction for Manifold-to-Scalar Kernel Regression — predict.m2skreg","text":"Given new observations \\(X_1, X_2, \\ldots, X_M \\\\mathcal{M}\\), plug  data respect fitted model prediction.","code":""},{"path":"https://kisungyou.com/Riemann/reference/predict.m2skreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction for Manifold-to-Scalar Kernel Regression — predict.m2skreg","text":"","code":"# S3 method for m2skreg predict(object, newdata, geometry = c(\"intrinsic\", \"extrinsic\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/predict.m2skreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction for Manifold-to-Scalar Kernel Regression — predict.m2skreg","text":"object object m2skreg class. See riem.m2skreg details. newdata S3 \"riemdata\" class manifold-valued data corresponding \\(X_1,\\ldots,X_M\\). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... arguments passed methods.","code":""},{"path":"https://kisungyou.com/Riemann/reference/predict.m2skreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction for Manifold-to-Scalar Kernel Regression — predict.m2skreg","text":"length-\\(M\\) vector predictted values.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/predict.m2skreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction for Manifold-to-Scalar Kernel Regression — predict.m2skreg","text":"","code":"# \\donttest{ #------------------------------------------------------------------- #                    Example on Sphere S^2 # #  X : equi-spaced points from (0,0,1) to (0,1,0) #  y : sin(x) with perturbation # #  Our goal is to check whether the predict function works well #  by comparing the originally predicted values vs. those of the same data. #------------------------------------------------------------------- # GENERATE DATA npts = 100 nlev = 0.25 thetas = seq(from=0, to=pi/2, length.out=npts) Xstack = cbind(rep(0,npts), sin(thetas), cos(thetas))  Xriem  = wrap.sphere(Xstack) ytrue  = sin(seq(from=0, to=2*pi, length.out=npts)) ynoise = ytrue + rnorm(npts, sd=nlev)  # FIT & PREDICT obj_fit   = riem.m2skreg(Xriem, ynoise, bandwidth=0.01) yval_fits = obj_fit$ypred yval_pred = predict(obj_fit, Xriem)  # VISUALIZE xgrd <- 1:npts opar <- par(no.readonly=TRUE) par(mfrow=c(1,2)) plot(xgrd, yval_fits, pch=19, cex=0.5, \"b\", xlab=\"\", ylim=c(-2,2), main=\"original fit\") lines(xgrd, ytrue, col=\"red\", lwd=1.5) plot(xgrd, yval_pred, pch=19, cex=0.5, \"b\", xlab=\"\", ylim=c(-2,2), main=\"from 'predict'\") lines(xgrd, ytrue, col=\"red\", lwd=1.5)  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/riem.clrq.html","id":null,"dir":"Reference","previous_headings":"","what":"Competitive Learning Riemannian Quantization — riem.clrq","title":"Competitive Learning Riemannian Quantization — riem.clrq","text":"Given \\(N\\) observations  \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  perform clustering via Competitive Learning Riemannian Quantization (CLRQ).  Originally, algorithm designed finding voronoi cells  used domain quantization. Given discrete measure data, centers cells  play role cluster centers data labeled accordingly based distance  voronoi centers. iterative update centers, gradient descent algorithm  adapted Riemannian manifold setting used gain factor sequence $$\\gamma_t = \\frac{}{1 + b \\sqrt{t}}$$ two parameters \\(,b\\) represented par.par.b.  initialization, provide k-means++ random seeding options k-means.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.clrq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Competitive Learning Riemannian Quantization — riem.clrq","text":"","code":"riem.clrq(riemobj, k = 2, init = c(\"plus\", \"random\"), gain.a = 1, gain.b = 1)"},{"path":"https://kisungyou.com/Riemann/reference/riem.clrq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Competitive Learning Riemannian Quantization — riem.clrq","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number clusters. init (case-insensitive) name initialization scheme. (default: \"plus\".) gain.parameter \\(\\) gain factor sequence. gain.b parameter \\(b\\) gain factor sequence.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.clrq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Competitive Learning Riemannian Quantization — riem.clrq","text":"named list containing centers 3d array slice along 3rd dimension matrix representation class centers. cluster length-\\(N\\) vector class labels (\\(1:k\\)).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.clrq.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Competitive Learning Riemannian Quantization — riem.clrq","text":"Le Brigant , Puechmorel S (2019). “Quantization clustering Riemannian manifolds application air traffic analysis.” Journal Multivariate Analysis, 173, 685--703. ISSN 0047259X. Bonnabel S (2013). “Stochastic Gradient Descent Riemannian Manifolds.” IEEE Transactions Automatic Control, 58(9), 2217--2229. ISSN 0018-9286, 1558-2523.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/riem.clrq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Competitive Learning Riemannian Quantization — riem.clrq","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## CLRQ WITH K=2,3,4 clust2 = riem.clrq(myriem, k=2) clust3 = riem.clrq(myriem, k=3) clust4 = riem.clrq(myriem, k=4)  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(2,2), pty=\"s\") plot(mds2d, pch=19, main=\"true label\", col=mylabs) plot(mds2d, pch=19, main=\"K=2\", col=clust2$cluster) plot(mds2d, pch=19, main=\"K=3\", col=clust3$cluster) plot(mds2d, pch=19, main=\"K=4\", col=clust4$cluster)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.coreset18B.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Lightweight Coreset — riem.coreset18B","title":"Build Lightweight Coreset — riem.coreset18B","text":"Given manifold-valued data \\(X_1,X_2,\\ldots,X_N \\\\mathcal{M}\\), algorithm  finds coreset size \\(M\\) can considered compressed representation  according lightweight coreset construction scheme proposed reference .","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.coreset18B.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Lightweight Coreset — riem.coreset18B","text":"","code":"riem.coreset18B(   riemobj,   M = length(riemobj$data)/2,   geometry = c(\"intrinsic\", \"extrinsic\"),   ... )"},{"path":"https://kisungyou.com/Riemann/reference/riem.coreset18B.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Lightweight Coreset — riem.coreset18B","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. M size coreset (default: \\(N/2\\)). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including maxiter maximum number iterations run (default:50). eps tolerance level stopping criterion (default: 1e-5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.coreset18B.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Lightweight Coreset — riem.coreset18B","text":"named list containing coreid length-\\(M\\) index vector coreset. weight length-\\(M\\) vector weights element.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.coreset18B.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Build Lightweight Coreset — riem.coreset18B","text":"Bachem O, Lucic M, Krause (2018). “Scalable k -Means Clustering via Lightweight Coresets.” Proceedings 24th ACM SIGKDD International Conference Knowledge Discovery \\& Data Mining, 1119--1127. ISBN 978-1-4503-5552-0.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.coreset18B.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build Lightweight Coreset — riem.coreset18B","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # * 10 perturbed data points near (1,0,0) on S^2 in R^3 # * 10 perturbed data points near (0,1,0) on S^2 in R^3 # * 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata)  ## MDS FOR VISUALIZATION embed2 = riem.mds(myriem, ndim=2)$embed  ## FIND CORESET OF SIZES 3, 6, 9 core1 = riem.coreset18B(myriem, M=3) core2 = riem.coreset18B(myriem, M=6) core3 = riem.coreset18B(myriem, M=9)  col1 = rep(1,30); col1[core1$coreid] = 2 col2 = rep(1,30); col2[core2$coreid] = 2 col3 = rep(1,30); col3[core3$coreid] = 2  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,3), pty=\"s\") plot(embed2, pch=19, col=col1, main=\"coreset size=3\") plot(embed2, pch=19, col=col2, main=\"coreset size=6\") plot(embed2, pch=19, col=col3, main=\"coreset size=9\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.distlp.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance between Two Curves on Manifolds — riem.distlp","title":"Distance between Two Curves on Manifolds — riem.distlp","text":"Given two curves \\(\\gamma_1, \\gamma_2 : \\rightarrow \\mathcal{M}\\),  interested measuring discrepancy two curves. Usually, data given  discrete observations offering several methods perform task. See  section detailed description.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.distlp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance between Two Curves on Manifolds — riem.distlp","text":"","code":"riem.distlp(   riemobj1,   riemobj2,   vect = NULL,   geometry = c(\"intrinsic\", \"extrinsic\"),   ... )"},{"path":"https://kisungyou.com/Riemann/reference/riem.distlp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance between Two Curves on Manifolds — riem.distlp","text":"riemobj1 S3 \"riemdata\" class \\(N\\) manifold-valued data along curve. riemobj2 S3 \"riemdata\" class \\(N\\) manifold-valued data along curve. vect vector domain values. given Null (default), sequence 1:N set. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including p exponent (default: 2).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.distlp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance between Two Curves on Manifolds — riem.distlp","text":"distance value.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.distlp.html","id":"default-method-","dir":"Reference","previous_headings":"","what":"Default Method","title":"Distance between Two Curves on Manifolds — riem.distlp","text":"Trapezoidal Approximation Assume \\(\\gamma_1 (t_i) = X_i\\) \\(\\gamma_2 (t_i) = Y_i\\)  \\(=1,2,\\ldots,N\\). Euclidean space, \\(L_p\\) distance two  scalar-valued functions defined  $$L_p^p (\\gamma_1 (x), \\gamma_2 (x) = \\int_{\\mathcal{X}} |\\gamma_1 (x) - \\gamma_2 (x)|^p dx $$.  extend approach manifold-valued curves $$L_p^p (\\gamma_1 (t), \\gamma_2 (t)) = \\int_{t\\} d^p (\\gamma_1 (t), \\gamma_2 (t)) dt$$ \\(d(\\cdot,\\cdot)\\) intrinsic/extrinsic distance manifolds. given  representations, integral approximated using trapezoidal rule.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.distlp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance between Two Curves on Manifolds — riem.distlp","text":"","code":"#------------------------------------------------------------------- #                          Curves on Sphere # #  curve1 : y = 0.5*cos(x) on the tangent space at (0,0,1) #  curve2 : y = 0.5*cos(x) on the tangent space at (0,0,1) #  curve3 : y = 0.5*sin(x) on the tangent space at (0,0,1) # # * distance between curve1 & curve2 should be close to 0. # * distance between curve1 & curve3 should be large. #------------------------------------------------------------------- ## GENERATION vecx  = seq(from=-0.9, to=0.9, length.out=50) vecy1 = 0.5*cos(vecx) + rnorm(50, sd=0.05) vecy2 = 0.5*cos(vecx) + rnorm(50, sd=0.05) vecy3 = 0.5*sin(vecx) + rnorm(50, sd=0.05)  ## WRAP AS RIEMOBJ mat1 = cbind(vecx, vecy1, 1); mat1 = mat1/sqrt(rowSums(mat1^2)) mat2 = cbind(vecx, vecy2, 1); mat2 = mat2/sqrt(rowSums(mat2^2)) mat3 = cbind(vecx, vecy3, 1); mat3 = mat3/sqrt(rowSums(mat3^2))  rcurve1 = wrap.sphere(mat1) rcurve2 = wrap.sphere(mat2) rcurve3 = wrap.sphere(mat3)  ## COMPUTE DISTANCES riem.distlp(rcurve1, rcurve2, vect=vecx) #> [1] 0.07341882 riem.distlp(rcurve1, rcurve3, vect=vecx) #> [1] 0.583167"},{"path":"https://kisungyou.com/Riemann/reference/riem.dtw.html","id":null,"dir":"Reference","previous_headings":"","what":"Dynamic Time Warping Distance — riem.dtw","title":"Dynamic Time Warping Distance — riem.dtw","text":"Given two time series - query \\(X = (X_1,X_2,\\ldots,X_N)\\) reference \\(Y = (Y_1,Y_2,\\ldots,Y_M)\\),  riem.dtw computes basic version Dynamic Time Warping (DTW) distance two series using symmetric step pattern, meaning  window constraints others . Although scope DTW Euclidean space-valued objects rich, scarce manifold-valued curves.  interested topic, refer dtw package.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.dtw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dynamic Time Warping Distance — riem.dtw","text":"","code":"riem.dtw(riemobj1, riemobj2, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.dtw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dynamic Time Warping Distance — riem.dtw","text":"riemobj1 S3 \"riemdata\" class \\(M\\) manifold-valued data along curve. riemobj2 S3 \"riemdata\" class \\(N\\) manifold-valued data along curve. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.dtw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dynamic Time Warping Distance — riem.dtw","text":"distance value.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.dtw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dynamic Time Warping Distance — riem.dtw","text":"","code":"# \\donttest{ #------------------------------------------------------------------- #                          Curves on Sphere # #  curve1 : y = 0.5*cos(x) on the tangent space at (0,0,1) #  curve2 : y = 0.5*sin(x) on the tangent space at (0,0,1) #  #  we will generate two sets for curves of different sizes. #------------------------------------------------------------------- ## GENERATION clist = list() for (i in 1:10){ # curve type 1   vecx = seq(from=-0.9, to=0.9, length.out=sample(10:50, 1))   vecy = 0.5*cos(vecx) + rnorm(length(vecx), sd=0.1)   mats = cbind(vecx, vecy, 1)   clist[[i]] = wrap.sphere(mats/sqrt(rowSums(mats^2))) } for (i in 1:10){ # curve type 2   vecx = seq(from=-0.9, to=0.9, length.out=sample(10:50, 1))   vecy = 0.5*sin(vecx) + rnorm(length(vecx), sd=0.1)   mats = cbind(vecx, vecy, 1)   clist[[i+10]] = wrap.sphere(mats/sqrt(rowSums(mats^2))) }  ## COMPUTE DISTANCES outint = array(0,c(20,20)) outext = array(0,c(20,20)) for (i in 1:19){   for (j in 2:20){     outint[i,j] <- outint[j,i] <- riem.dtw(clist[[i]], clist[[j]],                                             geometry=\"intrinsic\")     outext[i,j] <- outext[j,i] <- riem.dtw(clist[[i]], clist[[j]],                                            geometry=\"extrinsic\")   } }  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,2), pty=\"s\") image(outint[,20:1], axes=FALSE, main=\"intrinsic DTW Distance\") image(outext[,20:1], axes=FALSE, main=\"extrinsic DTW Distance\")  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/riem.fanova.html","id":null,"dir":"Reference","previous_headings":"","what":"Fréchet Analysis of Variance — riem.fanova","title":"Fréchet Analysis of Variance — riem.fanova","text":"Given sets manifold-valued data \\(X^{(1)}_{1:{n_1}}, X^{(2)}_{1:{n_2}}, \\ldots, X^{(m)}_{1:{n_m}}\\),  performs analysis variance test equality distributions. means, small \\(p\\)-value implies  least one equalities hold.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.fanova.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fréchet Analysis of Variance — riem.fanova","text":"","code":"riem.fanova(..., maxiter = 50, eps = 1e-05)  riem.fanovaP(..., maxiter = 50, eps = 1e-05, nperm = 99)"},{"path":"https://kisungyou.com/Riemann/reference/riem.fanova.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fréchet Analysis of Variance — riem.fanova","text":"... S3 objects riemdata class manifold-valued data. maxiter maximum number iterations run. eps tolerance level stopping criterion. nperm number permutations resampling-based test.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.fanova.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fréchet Analysis of Variance — riem.fanova","text":"(list) object S3 class htest containing: statistic test statistic. p.value \\(p\\)-value \\(H_0\\). alternative alternative hypothesis. method name test. data.name name(s) provided sample data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.fanova.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Fréchet Analysis of Variance — riem.fanova","text":"Dubey P, Müller H (2019). “Fréchet analysis variance random objects.” Biometrika, 106(4), 803--821. ISSN 0006-3444, 1464-3510.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.fanova.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fréchet Analysis of Variance — riem.fanova","text":"","code":"#------------------------------------------------------------------- #            Example on Sphere : Uniform Samples # #  Each of 4 classes consists of 20 uniform samples from uniform  #  density on 2-dimensional sphere S^2 in R^3. #------------------------------------------------------------------- ## PREPARE DATA OF 4 CLASSES ndata  = 200 class1 = list() class2 = list() class3 = list() class4 = list() for (i in 1:ndata){   tmpxy = matrix(rnorm(4*2, sd=0.1), ncol=2)   tmpz  = rep(1,4)   tmp3d = cbind(tmpxy, tmpz)   tmp  = tmp3d/sqrt(rowSums(tmp3d^2))      class1[[i]] = tmp[1,]   class2[[i]] = tmp[2,]   class3[[i]] = tmp[3,]   class4[[i]] = tmp[4,] } obj1 = wrap.sphere(class1) obj2 = wrap.sphere(class2) obj3 = wrap.sphere(class3) obj4 = wrap.sphere(class4)  ## RUN THE ASYMPTOTIC TEST riem.fanova(obj1, obj2, obj3, obj4) #>  #> \tFrechet Analysis of Variance on Sphere Manifold #>  #> data:  obj1, obj2, obj3, and obj4 #> Tn = 0.0014941, p-value = 1 #> alternative hypothesis: at least one of equalities does not hold. #>   # \\donttest{ ## RUN THE PERMUTATION TEST WITH MANY PERMUTATIONS riem.fanovaP(obj1, obj2, obj3, obj4, nperm=999) #>  #> \tFrechet Analysis of Variance on Sphere Manifold #>  #> data:  obj1, obj2, obj3, and obj4 #> Tn = 0.0014941, p-value = 0.767 #> alternative hypothesis: at least one of equalities does not hold. #>  # }"},{"path":"https://kisungyou.com/Riemann/reference/riem.hclust.html","id":null,"dir":"Reference","previous_headings":"","what":"Hierarchical Agglomerative Clustering — riem.hclust","title":"Hierarchical Agglomerative Clustering — riem.hclust","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_M \\\\mathcal{M}\\),  perform hierarchical agglomerative clustering  fastcluster package's implementation.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.hclust.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hierarchical Agglomerative Clustering — riem.hclust","text":"","code":"riem.hclust(   riemobj,   geometry = c(\"intrinsic\", \"extrinsic\"),   method = c(\"single\", \"complete\", \"average\", \"mcquitty\", \"ward.D\", \"ward.D2\",     \"centroid\", \"median\"),   members = NULL )"},{"path":"https://kisungyou.com/Riemann/reference/riem.hclust.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hierarchical Agglomerative Clustering — riem.hclust","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. method agglomeration method used. must one \"single\", \"complete\", \"average\", \"mcquitty\", \"ward.D\", \"ward.D2\", \"centroid\" \"median\". members NULL vector whose length equals number observations. See hclust details.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.hclust.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hierarchical Agglomerative Clustering — riem.hclust","text":"object class hclust. See hclust details.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.hclust.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hierarchical Agglomerative Clustering — riem.hclust","text":"Müllner D (2013). “fastcluster : Fast Hierarchical, Agglomerative Clustering Routines R Python.” Journal Statistical Software, 53(9). ISSN 1548-7660.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.hclust.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hierarchical Agglomerative Clustering — riem.hclust","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata)  ## COMPUTE SINGLE AND COMPLETE LINKAGE hc.sing <- riem.hclust(myriem, method=\"single\") hc.comp <- riem.hclust(myriem, method=\"complete\")  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,2)) plot(hc.sing, main=\"single linkage\") plot(hc.comp, main=\"complete linkage\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.interp.html","id":null,"dir":"Reference","previous_headings":"","what":"Geodesic Interpolation — riem.interp","title":"Geodesic Interpolation — riem.interp","text":"Given 2 observations \\(X_1, X_2 \\\\mathcal{M}\\), find interpolated  point geodesic \\(\\gamma(t)\\) \\(t \\(0,1)\\)  assumes two endpoints \\(\\gamma(0)=X_1\\) \\(\\gamma(1)=X_2\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.interp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geodesic Interpolation — riem.interp","text":"","code":"riem.interp(riemobj, t = 0.5, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.interp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geodesic Interpolation — riem.interp","text":"riemobj S3 \"riemdata\" class \\(2\\) manifold-valued data first object starting point. t scalar \\((0,1)\\) interpolation taken. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.interp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geodesic Interpolation — riem.interp","text":"interpolated object matrix representation \\(\\mathcal{M}\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.interp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geodesic Interpolation — riem.interp","text":"","code":"#------------------------------------------------------------------- #       Geodesic Interpolation between (1,0) and (0,1) in S^1 #------------------------------------------------------------------- ## PREPARE DATA sp.start = c(1,0) sp.end   = c(0,1) sp.data  = wrap.sphere(rbind(sp.start, sp.end))  ## FIND THE INTERPOLATED POINT AT \"t=0.25\" mid.int = as.vector(riem.interp(sp.data, t=0.25, geometry=\"intrinsic\")) mid.ext = as.vector(riem.interp(sp.data, t=0.25, geometry=\"extrinsic\"))  ## VISUALIZE #  Prepare Lines and Points thetas  = seq(from=0, to=pi/2, length.out=100) quarter = cbind(cos(thetas), sin(thetas)) pic.pts = rbind(sp.start, mid.int, mid.ext, sp.end) pic.col = c(\"black\",\"red\",\"green\",\"black\")  # Draw opar <- par(no.readonly=TRUE) par(pty=\"s\") plot(quarter, main=\"two interpolated points at t=0.25\",      xlab=\"x\", ylab=\"y\", type=\"l\") points(pic.pts, col=pic.col, pch=19) text(mid.int[1]-0.1, mid.int[2], \"intrinsic\", col=\"red\") text(mid.ext[1]-0.1, mid.ext[2], \"extrinsic\", col=\"green\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.interps.html","id":null,"dir":"Reference","previous_headings":"","what":"Geodesic Interpolation of Multiple Points — riem.interps","title":"Geodesic Interpolation of Multiple Points — riem.interps","text":"Given 2 observations \\(X_1, X_2 \\\\mathcal{M}\\), find  interpolated points geodesic \\(\\gamma(t)\\) \\(t \\(0,1)\\)  assumes two endpoints \\(\\gamma(0)=X_1\\) \\(\\gamma(1)=X_2\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.interps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geodesic Interpolation of Multiple Points — riem.interps","text":"","code":"riem.interps(   riemobj,   vect = c(0.25, 0.5, 0.75),   geometry = c(\"intrinsic\", \"extrinsic\") )"},{"path":"https://kisungyou.com/Riemann/reference/riem.interps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geodesic Interpolation of Multiple Points — riem.interps","text":"riemobj S3 \"riemdata\" class \\(2\\) manifold-valued data first object starting point. vect length-\\(T\\) vector \\((0,1)\\) interpolations taken. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.interps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geodesic Interpolation of Multiple Points — riem.interps","text":"3d array \\(T\\) slices along 3rd dimension interpolated objects matrix representation.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.interps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geodesic Interpolation of Multiple Points — riem.interps","text":"","code":"#------------------------------------------------------------------- #       Geodesic Interpolation between (1,0) and (0,1) in S^1 #------------------------------------------------------------------- ## PREPARE DATA sp.start = c(1,0) sp.end   = c(0,1) sp.data  = wrap.sphere(rbind(sp.start, sp.end))  ## FIND THE INTERPOLATED POINT AT FOR t=0.1, 0.2, ..., 0.9. myvect  = seq(from=0.1, to=0.9, by=0.1) geo.int = riem.interps(sp.data, vect=myvect, geometry=\"intrinsic\") geo.ext = riem.interps(sp.data, vect=myvect, geometry=\"extrinsic\")  geo.int = matrix(geo.int, byrow=TRUE, ncol=2) # re-arrange for plotting geo.ext = matrix(geo.ext, byrow=TRUE, ncol=2)  ## VISUALIZE #  Prepare Lines and Points thetas  = seq(from=0, to=pi/2, length.out=100) quarter = cbind(cos(thetas), sin(thetas))  pts.int = rbind(sp.start, geo.int, sp.end) pts.ext = rbind(sp.start, geo.ext, sp.end) col.int = c(\"black\", rep(\"red\",9),  \"black\") col.ext = c(\"black\", rep(\"blue\",9), \"black\")  # Draw opar <- par(no.readonly=TRUE) par(mfrow=c(1,2), pty=\"s\") plot(quarter, main=\"intrinsic interpolation\", # intrinsic geodesic      xlab=\"x\", ylab=\"y\", type=\"l\") points(pts.int, col=col.int, pch=19) for (i in 1:9){   text(geo.int[i,1]*0.9, geo.int[i,2]*0.9,         paste0(round(i/10,2)), col=\"red\") } plot(quarter, main=\"extrinsic interpolation\", # intrinsic geodesic      xlab=\"x\", ylab=\"y\", type=\"l\") points(pts.ext, col=col.ext, pch=19) for (i in 1:9){   text(geo.ext[i,1]*0.9, geo.ext[i,2]*0.9,         paste0(round(i/10,2)), col=\"blue\") }  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.isomap.html","id":null,"dir":"Reference","previous_headings":"","what":"Isometric Feature Mapping — riem.isomap","title":"Isometric Feature Mapping — riem.isomap","text":"ISOMAP - isometric feature mapping - dimensionality reduction method  apply classical multidimensional scaling geodesic distance  computed weighted nearest neighborhood graph. Nearest neighbor  defined \\(k\\)-NN two observations said connected  mutually included 's nearest neighbor. Note  possible geodesic distances Inf nearest neighbor  graph construction incurs separate connected components. extra  parameter padding=TRUE, infinite distances replaced 2 times  maximal finite geodesic distance.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.isomap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Isometric Feature Mapping — riem.isomap","text":"","code":"riem.isomap(   riemobj,   ndim = 2,   nnbd = 5,   geometry = c(\"intrinsic\", \"extrinsic\"),   ... )"},{"path":"https://kisungyou.com/Riemann/reference/riem.isomap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Isometric Feature Mapping — riem.isomap","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. ndim integer-valued target dimension (default: 2). nnbd size nearest neighborhood (default: 5). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including padding logical; TRUE, Inf-valued geodesic distances replaced 2 times maximal geodesic distance data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.isomap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Isometric Feature Mapping — riem.isomap","text":"named list containing embed \\((N\\times ndim)\\) matrix whose rows embedded observations.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.isomap.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Isometric Feature Mapping — riem.isomap","text":"Silva VD, Tenenbaum JB (2003). “Global Versus Local Methods Nonlinear Dimensionality Reduction.” Becker S, Thrun S, Obermayer K (eds.), Advances Neural Information Processing Systems 15, 721--728. MIT Press.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.isomap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Isometric Feature Mapping — riem.isomap","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # 10 perturbed data points near (1,0,0) on S^2 in R^3 # 10 perturbed data points near (0,1,0) on S^2 in R^3 # 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## MDS AND ISOMAP WITH DIFFERENT NEIGHBORHOOD SIZE mdss = riem.mds(myriem)$embed iso1 = riem.isomap(myriem, nnbd=5)$embed #> [1] \"* riem.isomap : some of the geodesic distances are Inf, so 'padding' is applied.\" iso2 = riem.isomap(myriem, nnbd=10)$embed  ## VISUALIZE opar = par(no.readonly=TRUE) par(mfrow=c(1,3), pty=\"s\") plot(mdss, col=mylabs, pch=19, main=\"MDS\") plot(iso1, col=mylabs, pch=19, main=\"ISOMAP:nnbd=5\") plot(iso2, col=mylabs, pch=19, main=\"ISOMAP:nnbd=10\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Means Clustering — riem.kmeans","title":"K-Means Clustering — riem.kmeans","text":"Given \\(N\\) observations  \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  perform k-means clustering minimizing within-cluster sum squares (WCSS).  Since problem NP-hard sensitive initialization, provide  option multiple starts return best result respect WCSS.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Means Clustering — riem.kmeans","text":"","code":"riem.kmeans(riemobj, k = 2, geometry = c(\"intrinsic\", \"extrinsic\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Means Clustering — riem.kmeans","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number clusters. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including algorithm (case-insensitive) name algorithm; \"MacQueen\" (default), \"Lloyd\". init (case-insensitive) name initialization scheme; \"plus\" k-means++ (default), \"random\". maxiter maximum number iterations run (default:50). nstart number random starts (default: 5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Means Clustering — riem.kmeans","text":"named list containing cluster length-\\(N\\) vector class labels (\\(1:k\\)). means 3d array slice along 3rd dimension matrix representation class mean. score within-cluster sum squares (WCSS).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"K-Means Clustering — riem.kmeans","text":"Lloyd S (1982). “Least squares quantization PCM.” IEEE Transactions Information Theory, 28(2), 129--137. ISSN 0018-9448. MacQueen J (1967). “methods classification analysis multivariate observations.” Proceedings fifth berkeley symposium mathematical statistics probability, volume 1: Statistics, 281--297.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Means Clustering — riem.kmeans","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## K-MEANS WITH K=2,3,4 clust2 = riem.kmeans(myriem, k=2) clust3 = riem.kmeans(myriem, k=3) clust4 = riem.kmeans(myriem, k=4)  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(2,2), pty=\"s\") plot(mds2d, pch=19, main=\"true label\", col=mylabs) plot(mds2d, pch=19, main=\"K=2\", col=clust2$cluster) plot(mds2d, pch=19, main=\"K=3\", col=clust3$cluster) plot(mds2d, pch=19, main=\"K=4\", col=clust4$cluster)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans18B.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Means Clustering with Lightweight Coreset — riem.kmeans18B","title":"K-Means Clustering with Lightweight Coreset — riem.kmeans18B","text":"modified version lightweight coreset scalable \\(k\\)-means computation  applied manifold-valued data \\(X_1,X_2,\\ldots,X_N \\\\mathcal{M}\\).  smaller set , faster execution becomes potentially larger quantization errors.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans18B.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Means Clustering with Lightweight Coreset — riem.kmeans18B","text":"","code":"riem.kmeans18B(   riemobj,   k = 2,   M = length(riemobj$data)/2,   geometry = c(\"intrinsic\", \"extrinsic\"),   ... )"},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans18B.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Means Clustering with Lightweight Coreset — riem.kmeans18B","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number clusters. M size coreset (default: \\(N/2\\)). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including maxiter maximum number iterations run (default:50). nstart number random starts (default: 5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans18B.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Means Clustering with Lightweight Coreset — riem.kmeans18B","text":"named list containing cluster length-\\(N\\) vector class labels (\\(1:k\\)). means 3d array slice along 3rd dimension matrix representation class mean. score within-cluster sum squares (WCSS).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans18B.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"K-Means Clustering with Lightweight Coreset — riem.kmeans18B","text":"Bachem O, Lucic M, Krause (2018). “Scalable k -Means Clustering via Lightweight Coresets.” Proceedings 24th ACM SIGKDD International Conference Knowledge Discovery \\& Data Mining, 1119--1127. ISBN 978-1-4503-5552-0.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeans18B.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Means Clustering with Lightweight Coreset — riem.kmeans18B","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## TRY DIFFERENT SIZES OF CORESET WITH K=4 FIXED core1 = riem.kmeans18B(myriem, k=3, M=5) core2 = riem.kmeans18B(myriem, k=3, M=10) core3 = riem.kmeans18B(myriem, k=3, M=15)  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(2,2), pty=\"s\") plot(mds2d, pch=19, main=\"true label\", col=mylabs) plot(mds2d, pch=19, main=\"kmeans18B: M=5\",  col=core1$cluster) plot(mds2d, pch=19, main=\"kmeans18B: M=10\", col=core2$cluster) plot(mds2d, pch=19, main=\"kmeans18B: M=15\", col=core3$cluster)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeanspp.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Means++ Clustering — riem.kmeanspp","title":"K-Means++ Clustering — riem.kmeanspp","text":"Given \\(N\\) observations  \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  perform k-means++ clustering algorithm using pairwise distances. algorithm  originally designed efficient initialization method k-means  algorithm.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeanspp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Means++ Clustering — riem.kmeanspp","text":"","code":"riem.kmeanspp(riemobj, k = 2, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeanspp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Means++ Clustering — riem.kmeanspp","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number clusters. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeanspp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Means++ Clustering — riem.kmeanspp","text":"named list containing centers length-\\(k\\) vector sampled centers' indices. cluster length-\\(N\\) vector class labels (\\(1:k\\)).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeanspp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"K-Means++ Clustering — riem.kmeanspp","text":"Arthur D, Vassilvitskii S (2007). “K-Means++: advantages careful seeding.” Proceedings eighteenth annual ACM-SIAM symposium discrete algorithms,  SODA '07, 1027--1035. ISBN 978-0-89871-624-5, Number pages: 9 Place: New Orleans, Louisiana.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmeanspp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Means++ Clustering — riem.kmeanspp","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## K-MEANS++ WITH K=2,3,4 clust2 = riem.kmeanspp(myriem, k=2) clust3 = riem.kmeanspp(myriem, k=3) clust4 = riem.kmeanspp(myriem, k=4)  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(2,2), pty=\"s\") plot(mds2d, pch=19, main=\"true label\", col=mylabs) plot(mds2d, pch=19, main=\"K=2\", col=clust2$cluster) plot(mds2d, pch=19, main=\"K=3\", col=clust3$cluster) plot(mds2d, pch=19, main=\"K=4\", col=clust4$cluster)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.kmedoids.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Medoids Clustering — riem.kmedoids","title":"K-Medoids Clustering — riem.kmedoids","text":"Given \\(N\\) observations  \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  perform k-medoids clustering using pairwise distances.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmedoids.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Medoids Clustering — riem.kmedoids","text":"","code":"riem.kmedoids(riemobj, k = 2, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.kmedoids.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Medoids Clustering — riem.kmedoids","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number clusters. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kmedoids.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Medoids Clustering — riem.kmedoids","text":"named list containing medoids length-\\(k\\) vector medoids' indices. cluster length-\\(N\\) vector class labels (\\(1:k\\)).","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/riem.kmedoids.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Medoids Clustering — riem.kmedoids","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## K-MEDOIDS WITH K=2,3,4 clust2 = riem.kmedoids(myriem, k=2) clust3 = riem.kmedoids(myriem, k=3) clust4 = riem.kmedoids(myriem, k=4)  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(2,2), pty=\"s\") plot(mds2d, pch=19, main=\"true label\", col=mylabs) plot(mds2d, pch=19, main=\"K=2\", col=clust2$cluster) plot(mds2d, pch=19, main=\"K=3\", col=clust3$cluster) plot(mds2d, pch=19, main=\"K=4\", col=clust4$cluster)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.knn.html","id":null,"dir":"Reference","previous_headings":"","what":"Find K-Nearest Neighbors — riem.knn","title":"Find K-Nearest Neighbors — riem.knn","text":"Given \\(N\\) observations  \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  riem.knn constructs \\(k\\)-nearest neighbors.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.knn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find K-Nearest Neighbors — riem.knn","text":"","code":"riem.knn(riemobj, k = 2, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.knn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find K-Nearest Neighbors — riem.knn","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number neighbors find. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.knn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find K-Nearest Neighbors — riem.knn","text":"named list containing nn.idx \\((N \\times k)\\) neighborhood index matrix. nn.dists \\((N\\times k)\\) distances point neighbors.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.knn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find K-Nearest Neighbors — riem.knn","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # * 10 perturbed data points near (1,0,0) on S^2 in R^3 # * 10 perturbed data points near (0,1,0) on S^2 in R^3 # * 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(2,3,4), each=10)  ## K-NN CONSTRUCTION WITH K=5 & K=10 knn1 = riem.knn(myriem, k=5) knn2 = riem.knn(myriem, k=10)  ## MDS FOR VISUALIZATION embed2 = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,2), pty=\"s\") plot(embed2, pch=19, main=\"knn with k=4\", col=mylabs) for (i in 1:30){   for (j in 1:5){     lines(embed2[c(i,knn1$nn.idx[i,j]),])   } } plot(embed2, pch=19, main=\"knn with k=8\", col=mylabs) for (i in 1:30){   for (j in 1:10){     lines(embed2[c(i,knn2$nn.idx[i,j]),])   } }  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.kpca.html","id":null,"dir":"Reference","previous_headings":"","what":"Kernel Principal Component Analysis — riem.kpca","title":"Kernel Principal Component Analysis — riem.kpca","text":"Although method Kernel Principal Component Analysis (KPCA) originally  developed visualize non-linearly distributed data Euclidean space,  graft case manifolds extrinsic geometry explicitly available. algorithm uses Gaussian kernel  $$K(X_i, X_j) = \\exp\\left( - \\frac{d^2 (X_i, X_j)}{2 \\sigma^2} \\right )$$ \\(\\sigma\\) bandwidth parameter \\(d(\\cdot, \\cdot)\\)  extrinsic distance defined specific manifold.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kpca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kernel Principal Component Analysis — riem.kpca","text":"","code":"riem.kpca(riemobj, ndim = 2, sigma = 1)"},{"path":"https://kisungyou.com/Riemann/reference/riem.kpca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kernel Principal Component Analysis — riem.kpca","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. ndim integer-valued target dimension (default: 2). sigma bandwidth parameter (default: 1).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kpca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kernel Principal Component Analysis — riem.kpca","text":"named list containing embed \\((N\\times ndim)\\) matrix whose rows embedded observations. vars length-\\(N\\) vector eigenvalues kernelized covariance matrix.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kpca.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Kernel Principal Component Analysis — riem.kpca","text":"Schölkopf B, Smola , Müller K (1997). “Kernel principal component analysis.” Goos G, Hartmanis J, van Leeuwen J, Gerstner W, Germond , Hasler M, Nicoud J (eds.), Artificial Neural Networks — ICANN'97, volume 1327, 583--588. Springer Berlin Heidelberg, Berlin, Heidelberg. ISBN 978-3-540-63631-1 978-3-540-69620-9.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.kpca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kernel Principal Component Analysis — riem.kpca","text":"","code":"#------------------------------------------------------------------- #          Example for Gorilla Skull Data : 'gorilla' #------------------------------------------------------------------- ## PREPARE THE DATA #  Aggregate two classes into one set data(gorilla)  mygorilla = array(0,c(8,2,59)) for (i in 1:29){   mygorilla[,,i] = gorilla$male[,,i] } for (i in 30:59){   mygorilla[,,i] = gorilla$female[,,i-29] }  gor.riem = wrap.landmark(mygorilla) gor.labs = c(rep(\"red\",29), rep(\"blue\",30))  ## APPLY KPCA WITH DIFFERENT KERNEL BANDWIDTHS kpca1 = riem.kpca(gor.riem, sigma=0.01) kpca2 = riem.kpca(gor.riem, sigma=1) kpca3 = riem.kpca(gor.riem, sigma=100) ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,3), pty=\"s\") plot(kpca1$embed, pch=19, col=gor.labs, main=\"sigma=1/100\") plot(kpca2$embed, pch=19, col=gor.labs, main=\"sigma=1\") plot(kpca3$embed, pch=19, col=gor.labs, main=\"sigma=100\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skreg.html","id":null,"dir":"Reference","previous_headings":"","what":"Manifold-to-Scalar Kernel Regression — riem.m2skreg","title":"Manifold-to-Scalar Kernel Regression — riem.m2skreg","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\)  scalars \\(y_1, y_2, \\ldots, y_N \\\\mathbf{R}\\), perform Nadaraya-Watson kernel  regression  $$\\hat{m}_h (X) = \\frac{\\sum_{=1}^n K \\left( \\frac{d(X,X_i)}{h}  \\right) y_i}{\\sum_{=1}^n K \\left( \\frac{d(X,X_i)}{h}  \\right)}$$ Gaussian kernel defined $$K(x) := \\frac{1}{\\sqrt{2\\pi}} \\exp \\left( - \\frac{x^2}{2}\\right)$$  bandwidth parameter \\(h > 0\\) controls degree smoothness.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skreg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manifold-to-Scalar Kernel Regression — riem.m2skreg","text":"","code":"riem.m2skreg(   riemobj,   y,   bandwidth = 0.5,   geometry = c(\"intrinsic\", \"extrinsic\") )"},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skreg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manifold-to-Scalar Kernel Regression — riem.m2skreg","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data corresponding \\(X_1,\\ldots,X_N\\). y length-\\(N\\) vector dependent variable values. bandwidth nonnegative number controls smoothness. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skreg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manifold-to-Scalar Kernel Regression — riem.m2skreg","text":"named list S3 class m2skreg containing ypred length-\\(N\\) vector smoothed responses. bandwidth bandwidth value originally provided, saved future use. inputs list containing riemobj y future use.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skreg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manifold-to-Scalar Kernel Regression — riem.m2skreg","text":"","code":"# \\donttest{ #------------------------------------------------------------------- #                    Example on Sphere S^2 # #  X : equi-spaced points from (0,0,1) to (0,1,0) #  y : sin(x) with perturbation #------------------------------------------------------------------- # GENERATE DATA npts = 100 nlev = 0.25 thetas = seq(from=0, to=pi/2, length.out=npts) Xstack = cbind(rep(0,npts), sin(thetas), cos(thetas))  Xriem  = wrap.sphere(Xstack) ytrue  = sin(seq(from=0, to=2*pi, length.out=npts)) ynoise = ytrue + rnorm(npts, sd=nlev)  # FIT WITH DIFFERENT BANDWIDTHS fit1 = riem.m2skreg(Xriem, ynoise, bandwidth=0.001) fit2 = riem.m2skreg(Xriem, ynoise, bandwidth=0.01) fit3 = riem.m2skreg(Xriem, ynoise, bandwidth=0.1)  # VISUALIZE xgrd <- 1:npts opar <- par(no.readonly=TRUE) par(mfrow=c(1,3)) plot(xgrd, fit1$ypred, pch=19, cex=0.5, \"b\", xlab=\"\", ylim=c(-2,2), main=\"h=1e-3\") lines(xgrd, ytrue, col=\"red\", lwd=1.5) plot(xgrd, fit2$ypred, pch=19, cex=0.5, \"b\", xlab=\"\", ylim=c(-2,2), main=\"h=1e-2\") lines(xgrd, ytrue, col=\"red\", lwd=1.5) plot(xgrd, fit3$ypred, pch=19, cex=0.5, \"b\", xlab=\"\", ylim=c(-2,2), main=\"h=1e-1\") lines(xgrd, ytrue, col=\"red\", lwd=1.5)  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skregCV.html","id":null,"dir":"Reference","previous_headings":"","what":"Manifold-to-Scalar Kernel Regression with K-Fold Cross Validation — riem.m2skregCV","title":"Manifold-to-Scalar Kernel Regression with K-Fold Cross Validation — riem.m2skregCV","text":"Manifold--Scalar Kernel Regression K-Fold Cross Validation","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skregCV.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manifold-to-Scalar Kernel Regression with K-Fold Cross Validation — riem.m2skregCV","text":"","code":"riem.m2skregCV(   riemobj,   y,   bandwidths = seq(from = 0.01, to = 1, length.out = 10),   geometry = c(\"intrinsic\", \"extrinsic\"),   kfold = 5 )"},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skregCV.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manifold-to-Scalar Kernel Regression with K-Fold Cross Validation — riem.m2skregCV","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data corresponding \\(X_1,\\ldots,X_N\\). y length-\\(N\\) vector dependent variable values. bandwidths vector nonnegative numbers control smoothness. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. kfold number folds cross validation.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skregCV.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manifold-to-Scalar Kernel Regression with K-Fold Cross Validation — riem.m2skregCV","text":"named list S3 class m2skreg containing ypred length-\\(N\\) vector optimal smoothed responses. bandwidth optimal bandwidth value. inputs list containing riemobj y future use. errors matrix whose columns bandwidths values corresponding errors measure SSE.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.m2skregCV.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Manifold-to-Scalar Kernel Regression with K-Fold Cross Validation — riem.m2skregCV","text":"","code":"# \\donttest{ #------------------------------------------------------------------- #                    Example on Sphere S^2 # #  X : equi-spaced points from (0,0,1) to (0,1,0) #  y : sin(x) with perturbation #------------------------------------------------------------------- # GENERATE DATA set.seed(496)  npts = 100 nlev = 0.25 thetas = seq(from=0, to=pi/2, length.out=npts) Xstack = cbind(rep(0,npts), sin(thetas), cos(thetas))  Xriem  = wrap.sphere(Xstack) ytrue  = sin(seq(from=0, to=2*pi, length.out=npts)) ynoise = ytrue + rnorm(npts, sd=nlev)  # FIT WITH 5-FOLD CV cv_band = (10^seq(from=-4, to=-1, length.out=200)) cv_fit  = riem.m2skregCV(Xriem, ynoise, bandwidths=cv_band) cv_err  = cv_fit$errors  # VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,2)) plot(1:npts, cv_fit$ypred, pch=19, cex=0.5, \"b\", xlab=\"\", main=\"optimal prediction\") lines(1:npts, ytrue, col=\"red\", lwd=1.5) plot(cv_err[,1], cv_err[,2], \"b\", pch=19, cex=0.5, main=\"5-fold CV errors\",      xlab=\"bandwidth\", ylab=\"SSE\") abline(v=cv_fit$bandwidth, col=\"blue\", lwd=1.5)  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/riem.mds.html","id":null,"dir":"Reference","previous_headings":"","what":"Multidimensional Scaling — riem.mds","title":"Multidimensional Scaling — riem.mds","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  apply multidimensional scaling get low-dimensional embedding  Euclidean space. Usually, ndim=2,3 chosen visualization.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.mds.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multidimensional Scaling — riem.mds","text":"","code":"riem.mds(riemobj, ndim = 2, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.mds.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multidimensional Scaling — riem.mds","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. ndim integer-valued target dimension (default: 2). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.mds.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multidimensional Scaling — riem.mds","text":"named list containing embed \\((N\\times ndim)\\) matrix whose rows embedded observations. stress discrepancy embedded original distances measure error.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.mds.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Multidimensional Scaling — riem.mds","text":"Torgerson WS (1952). “Multidimensional scaling: . Theory method.” Psychometrika, 17(4), 401--419. ISSN 0033-3123, 1860-0980.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.mds.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multidimensional Scaling — riem.mds","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # 10 perturbed data points near (1,0,0) on S^2 in R^3 # 10 perturbed data points near (0,1,0) on S^2 in R^3 # 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## MDS EMBEDDING WITH TWO GEOMETRIES embed2int = riem.mds(myriem, geometry=\"intrinsic\")$embed embed2ext = riem.mds(myriem, geometry=\"extrinsic\")$embed  ## VISUALIZE opar = par(no.readonly=TRUE) par(mfrow=c(1,2), pty=\"s\") plot(embed2int, main=\"intrinsic MDS\", ylim=c(-2,2), col=mylabs, pch=19) plot(embed2ext, main=\"extrinsic MDS\", ylim=c(-2,2), col=mylabs, pch=19)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Fréchet Mean and Variation — riem.mean","title":"Fréchet Mean and Variation — riem.mean","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  compute Fréchet mean variation respect geometry minimizing $$\\textrm{min}_x \\sum_{n=1}^N w_n \\rho^2 (x, x_n),\\quad x\\\\mathcal{M}$$ \\(\\rho (x, y)\\) distance two points \\(x,y\\\\mathcal{M}\\).  non-uniform weights given, normalized version mean computed  weight=NULL, automatically sets equal weights (\\(w_i = 1/n\\)) observations.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fréchet Mean and Variation — riem.mean","text":"","code":"riem.mean(riemobj, weight = NULL, geometry = c(\"intrinsic\", \"extrinsic\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/riem.mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fréchet Mean and Variation — riem.mean","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. weight weight observations; NULL assumes equal weights, nonnegative length-\\(N\\) vector sums 1 given. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including maxiter maximum number iterations run (default:50). eps tolerance level stopping criterion (default: 1e-5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fréchet Mean and Variation — riem.mean","text":"named list containing mean mean matrix \\(\\mathcal{M}\\). variation sum (weighted) squared distances.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fréchet Mean and Variation — riem.mean","text":"","code":"#------------------------------------------------------------------- #        Example on Sphere : points near (0,1) on S^1 in R^2 #------------------------------------------------------------------- ## GENERATE DATA ndata = 50 mydat = array(0,c(ndata,2)) for (i in 1:ndata){   tgt = c(stats::rnorm(1, sd=2), 1)   mydat[i,] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydat)  ## COMPUTE TWO MEANS mean.int = as.vector(riem.mean(myriem, geometry=\"intrinsic\")$mean) mean.ext = as.vector(riem.mean(myriem, geometry=\"extrinsic\")$mean)  ## VISUALIZE opar <- par(no.readonly=TRUE) plot(mydat[,1], mydat[,2], pch=19, xlim=c(-1.1,1.1), ylim=c(0,1.1),      main=\"BLUE-extrinsic vs RED-intrinsic\") arrows(x0=0,y0=0,x1=mean.int[1],y1=mean.int[2],col=\"red\") arrows(x0=0,y0=0,x1=mean.ext[1],y1=mean.ext[2],col=\"blue\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.median.html","id":null,"dir":"Reference","previous_headings":"","what":"Fréchet Median and Variation — riem.median","title":"Fréchet Median and Variation — riem.median","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  compute Fréchet median variation respect geometry minimizing $$\\textrm{min}_x \\sum_{n=1}^N w_n \\rho (x, x_n),\\quad x\\\\mathcal{M}$$ \\(\\rho (x, y)\\) distance two points \\(x,y\\\\mathcal{M}\\).  non-uniform weights given, normalized version mean computed  weight=NULL, automatically sets equal weights observations.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.median.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fréchet Median and Variation — riem.median","text":"","code":"riem.median(   riemobj,   weight = NULL,   geometry = c(\"intrinsic\", \"extrinsic\"),   ... )"},{"path":"https://kisungyou.com/Riemann/reference/riem.median.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fréchet Median and Variation — riem.median","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. weight weight observations; NULL assumes equal weights, nonnegative length-\\(N\\) vector sums 1 given. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including maxiter maximum number iterations run (default:50). eps tolerance level stopping criterion (default: 1e-5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.median.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fréchet Median and Variation — riem.median","text":"named list containing median median matrix \\(\\mathcal{M}\\). variation sum (weighted) distances.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.median.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fréchet Median and Variation — riem.median","text":"","code":"#------------------------------------------------------------------- #        Example on Sphere : points near (0,1) on S^1 in R^2 #------------------------------------------------------------------- ## GENERATE DATA ndata = 50 mydat = array(0,c(ndata,2)) for (i in 1:ndata){   tgt = c(stats::rnorm(1, sd=2), 1)   mydat[i,] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydat)  ## COMPUTE TWO MEANS med.int = as.vector(riem.median(myriem, geometry=\"intrinsic\")$median) med.ext = as.vector(riem.median(myriem, geometry=\"extrinsic\")$median)  ## VISUALIZE opar <- par(no.readonly=TRUE) plot(mydat[,1], mydat[,2], pch=19, xlim=c(-1.1,1.1), ylim=c(0,1.1),      main=\"BLUE-extrinsic vs RED-intrinsic\") arrows(x0=0,y0=0,x1=med.int[1],y1=med.int[2],col=\"red\") arrows(x0=0,y0=0,x1=med.ext[1],y1=med.ext[2],col=\"blue\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.nmshift.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonlinear Mean Shift — riem.nmshift","title":"Nonlinear Mean Shift — riem.nmshift","text":"Given \\(N\\) observations  \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  perform clustering data based nonlinear mean shift algorithm.  Gaussian kernel used bandwidth \\(h\\)  $$G(x_i, x_j) \\propto \\exp \\left( - \\frac{\\rho^2 (x_i,x_j)}{h^2} \\right)$$ \\(\\rho(x,y)\\) geodesic distance two points \\(x,y\\\\mathcal{M}\\).  Numerically, limiting points collapse cluster  exact. purpose, require maxk parameter search  optimal number clusters based \\(k\\)-medoids clustering algorithm  conjunction silhouette criterion.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.nmshift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonlinear Mean Shift — riem.nmshift","text":"","code":"riem.nmshift(riemobj, h = 1, maxk = 5, maxiter = 50, eps = 1e-05)"},{"path":"https://kisungyou.com/Riemann/reference/riem.nmshift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonlinear Mean Shift — riem.nmshift","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. h bandwidth parameter. larger \\(h\\) , blurring applied. maxk maximum number clusters determine optimal number clusters. maxiter maximum number iterations run. eps tolerance level stopping criterion.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.nmshift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonlinear Mean Shift — riem.nmshift","text":"named list containing distance \\((N\\times N)\\) distance modes corresponding data point. cluster length-\\(N\\) vector class labels.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.nmshift.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nonlinear Mean Shift — riem.nmshift","text":"Subbarao R, Meer P (2009). “Nonlinear Mean Shift Riemannian Manifolds.” International Journal Computer Vision, 84(1), 1--20. ISSN 0920-5691, 1573-1405.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.nmshift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonlinear Mean Shift — riem.nmshift","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA set.seed(496) ndata  = 10 mydata = list() for (i in 1:ndata){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in (ndata+1):(2*ndata)){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in ((2*ndata)+1):(3*ndata)){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=ndata)  ## RUN NONLINEAR MEANSHIFT FOR DIFFERENT 'h' VALUES run1 = riem.nmshift(myriem, maxk=10, h=0.1) run2 = riem.nmshift(myriem, maxk=10, h=1) run3 = riem.nmshift(myriem, maxk=10, h=10)  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(2,3), pty=\"s\") plot(mds2d, pch=19, main=\"label : h=0.1\", col=run1$cluster) plot(mds2d, pch=19, main=\"label : h=1\",   col=run2$cluster) plot(mds2d, pch=19, main=\"label : h=10\",  col=run3$cluster) image(run1$distance[,30:1], axes=FALSE, main=\"distance : h=0.1\") image(run2$distance[,30:1], axes=FALSE, main=\"distance : h=1\") image(run3$distance[,30:1], axes=FALSE, main=\"distance : h=10\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Pairwise Distances for Data — riem.pdist","title":"Compute Pairwise Distances for Data — riem.pdist","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\), compute  pairwise distances.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Pairwise Distances for Data — riem.pdist","text":"","code":"riem.pdist(riemobj, geometry = c(\"intrinsic\", \"extrinsic\"), as.dist = FALSE)"},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Pairwise Distances for Data — riem.pdist","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry .dist logical; TRUE, returns dist object, else returns symmetric matrix.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Pairwise Distances for Data — riem.pdist","text":"S3 dist object \\((N\\times N)\\) symmetric matrix pairwise distances according .dist parameter.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Pairwise Distances for Data — riem.pdist","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with two types # #  group1 : perturbed data points near (0,0,1) on S^2 in R^3 #  group2 : perturbed data points near (1,0,0) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() sdval  = 0.1 for (i in 1:10){   tgt = c(stats::rnorm(2, sd=sdval), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(1, stats::rnorm(2, sd=sdval))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata)  ## COMPARE TWO DISTANCES dint = riem.pdist(myriem, geometry=\"intrinsic\", as.dist=FALSE) dext = riem.pdist(myriem, geometry=\"extrinsic\", as.dist=FALSE)  ## VISUALIZE opar = par(no.readonly=TRUE) par(mfrow=c(1,2), pty=\"s\") image(dint[,nrow(dint):1], main=\"intrinsic\", axes=FALSE) image(dext[,nrow(dext):1], main=\"extrinsic\", axes=FALSE)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist2.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Pairwise Distances for Two Sets of Data — riem.pdist2","title":"Compute Pairwise Distances for Two Sets of Data — riem.pdist2","text":"Given \\(M\\) observations \\(X_1, X_2, \\ldots, X_M \\\\mathcal{M}\\)  \\(N\\) observations \\(Y_1, Y_2, \\ldots, Y_N \\\\mathcal{M}\\),  compute pairwise distances two sets' elements.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Pairwise Distances for Two Sets of Data — riem.pdist2","text":"","code":"riem.pdist2(riemobj1, riemobj2, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Pairwise Distances for Two Sets of Data — riem.pdist2","text":"riemobj1 S3 \"riemdata\" class \\(M\\) manifold-valued data. riemobj2 S3 \"riemdata\" class \\(N\\) manifold-valued data. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Pairwise Distances for Two Sets of Data — riem.pdist2","text":"\\((M\\times N)\\) matrix distances.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pdist2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Pairwise Distances for Two Sets of Data — riem.pdist2","text":"","code":"# \\donttest{ #------------------------------------------------------------------- #          Example on Sphere : a dataset with two types # #  group1 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #  group2 : 10 perturbed data points near (1,0,0) on S^2 in R^3 #           10 perturbed data points near (0,1,0) on S^2 in R^3 #           10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata1 = list() mydata2 = list() for (i in 1:10){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata1[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata2[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata2[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata2[[i]] = tgt/sqrt(sum(tgt^2)) } myriem1 = wrap.sphere(mydata1) myriem2 = wrap.sphere(mydata2)  ## COMPARE TWO DISTANCES dint = riem.pdist2(myriem1, myriem2, geometry=\"intrinsic\") dext = riem.pdist2(myriem1, myriem2, geometry=\"extrinsic\")  ## VISUALIZE opar = par(no.readonly=TRUE) par(mfrow=c(1,2)) image(dint[nrow(dint):1,], main=\"intrinsic\", axes=FALSE) image(dext[nrow(dext):1,], main=\"extrinsic\", axes=FALSE)  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/riem.pga.html","id":null,"dir":"Reference","previous_headings":"","what":"Principal Geodesic Analysis — riem.pga","title":"Principal Geodesic Analysis — riem.pga","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  Principal Geodesic Analysis (PGA) finds low-dimensional embedding decomposing  2nd-order information tangent space intrinsic mean data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pga.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Principal Geodesic Analysis — riem.pga","text":"","code":"riem.pga(riemobj, ndim = 2)"},{"path":"https://kisungyou.com/Riemann/reference/riem.pga.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Principal Geodesic Analysis — riem.pga","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. ndim integer-valued target dimension.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pga.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Principal Geodesic Analysis — riem.pga","text":"named list containing center intrinsic mean matrix representation form. embed \\((N\\times ndim)\\) matrix whose rows embedded observations.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pga.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Principal Geodesic Analysis — riem.pga","text":"Fletcher PT, Lu C, Pizer SM, Joshi S (2004). “Principal Geodesic Analysis Study Nonlinear Statistics Shape.” IEEE Transactions Medical Imaging, 23(8), 995--1005. ISSN 0278-0062.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.pga.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Principal Geodesic Analysis — riem.pga","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # 10 perturbed data points near (1,0,0) on S^2 in R^3 # 10 perturbed data points near (0,1,0) on S^2 in R^3 # 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## EMBEDDING WITH MDS AND PGA embed2mds = riem.mds(myriem, ndim=2, geometry=\"intrinsic\")$embed embed2pga = riem.pga(myriem, ndim=2)$embed  ## VISUALIZE opar = par(no.readonly=TRUE) par(mfrow=c(1,2), pty=\"s\") plot(embed2mds, main=\"Multidimensional Scaling\",    col=mylabs, pch=19) plot(embed2pga, main=\"Principal Geodesic Analysis\", col=mylabs, pch=19)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.phate.html","id":null,"dir":"Reference","previous_headings":"","what":"PHATE — riem.phate","title":"PHATE — riem.phate","text":"PHATE nonlinear manifold learning method specifically targeted  improving diffusion maps incorporating data-adaptive kernel construction,  detection optimal time scale, information-theoretic metric measures.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.phate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PHATE — riem.phate","text":"","code":"riem.phate(riemobj, ndim = 2, geometry = c(\"intrinsic\", \"extrinsic\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/riem.phate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PHATE — riem.phate","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. ndim integer-valued target dimension (default: 2). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters PHATE including nbdk size nearest neighborhood (default: 5). alpha decay parameter Gaussian kernel exponent (default: 2). potential type potential distance transformation; \"log\" \"sqrt\" (default: \"log\").","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.phate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PHATE — riem.phate","text":"named list containing embed \\((N\\times ndim)\\) matrix whose rows embedded observations.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.phate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PHATE — riem.phate","text":"Moon KR, van Dijk D, Wang Z, Gigante S, Burkhardt DB, Chen WS, Yim K, van den Elzen , Hirn MJ, Coifman RR, Ivanova NB, Wolf G, Krishnaswamy S (2019). “Visualizing Structure Transitions High-Dimensional Biological Data.” Nature Biotechnology, 37(12), 1482--1492. ISSN 1087-0156, 1546-1696.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.phate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PHATE — riem.phate","text":"","code":"# \\donttest{ #------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # 10 perturbed data points near (1,0,0) on S^2 in R^3 # 10 perturbed data points near (0,1,0) on S^2 in R^3 # 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## PHATE EMBEDDING WITH LOG & SQRT POTENTIAL  phate_log  = riem.phate(myriem, potential=\"log\")$embed phate_sqrt = riem.phate(myriem, potential=\"sqrt\")$embed embed_mds  = riem.mds(myriem)$embed  ## VISUALIZE opar = par(no.readonly=TRUE) par(mfrow=c(1,3), pty=\"s\") plot(embed_mds,  col=mylabs, pch=19, main=\"MDS\" ) plot(phate_log,  col=mylabs, pch=19, main=\"PHATE+Log\") plot(phate_sqrt, col=mylabs, pch=19, main=\"PHATE+Sqrt\")  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/riem.rmml.html","id":null,"dir":"Reference","previous_headings":"","what":"Riemannian Manifold Metric Learning — riem.rmml","title":"Riemannian Manifold Metric Learning — riem.rmml","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\)  corresponding label information, riem.rmml computes pairwise distance data Riemannian Manifold Metric Learning  (RMML) framework based equivariant embedding. number data points  sufficient, inverse scatter matrix exist analytically  small regularization parameter \\(\\lambda\\) recommended default value \\(\\lambda=0.1\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.rmml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Riemannian Manifold Metric Learning — riem.rmml","text":"","code":"riem.rmml(riemobj, label, lambda = 0.1, as.dist = FALSE)"},{"path":"https://kisungyou.com/Riemann/reference/riem.rmml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Riemannian Manifold Metric Learning — riem.rmml","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. label length-\\(N\\) vector class labels. NA values omitted. lambda regularization parameter. \\(\\lambda \\leq 0\\), regularization applied. .dist logical; TRUE, returns dist object, else returns symmetric matrix.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.rmml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Riemannian Manifold Metric Learning — riem.rmml","text":"S3 dist object \\((N\\times N)\\) symmetric matrix pairwise distances according .dist parameter.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.rmml.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Riemannian Manifold Metric Learning — riem.rmml","text":"Zhu P, Cheng H, Hu Q, Wang Q, Zhang C (2018). “Towards Generalized Efficient Metric Learning Riemannian Manifold.” Proceedings Twenty-Seventh International Joint Conference Artificial Intelligence, 3235--3241. ISBN 978-0-9992411-2-7.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.rmml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Riemannian Manifold Metric Learning — riem.rmml","text":"","code":"#------------------------------------------------------------------- #            Distance between Two Classes of SPD Matrices # #  Class 1 : Empirical Covariance from Standard Normal Distribution #  Class 2 : Empirical Covariance from Perturbed 'iris' dataset #------------------------------------------------------------------- ## DATA GENERATION data(iris) ndata  = 10 mydata = list() for (i in 1:ndata){   mydata[[i]] = stats::cov(matrix(rnorm(100*4),ncol=4)) } for (i in (ndata+1):(2*ndata)){   tmpdata = as.matrix(iris[,1:4]) + matrix(rnorm(150*4,sd=0.5),ncol=4)   mydata[[i]] = stats::cov(tmpdata) } myriem = wrap.spd(mydata) mylabs = rep(c(1,2), each=ndata)  ## COMPUTE GEODESIC AND RMML PAIRWISE DISTANCE pdgeo = riem.pdist(myriem) pdmdl = riem.rmml(myriem, label=mylabs)  ## VISUALIZE opar = par(no.readonly=TRUE) par(mfrow=c(1,2), pty=\"s\") image(pdgeo[,(2*ndata):1], main=\"geodesic distance\", axes=FALSE) image(pdmdl[,(2*ndata):1], main=\"RMML distance\", axes=FALSE)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.sammon.html","id":null,"dir":"Reference","previous_headings":"","what":"Sammon Mapping — riem.sammon","title":"Sammon Mapping — riem.sammon","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  apply Sammon mapping, non-linear dimensionality reduction method. Since  method depends pairwise distances data, can  adapted manifold-valued data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.sammon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sammon Mapping — riem.sammon","text":"","code":"riem.sammon(riemobj, ndim = 2, geometry = c(\"intrinsic\", \"extrinsic\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/riem.sammon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sammon Mapping — riem.sammon","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. ndim integer-valued target dimension (default: 2). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including maxiter maximum number iterations run (default:50). eps tolerance level stopping criterion (default: 1e-5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.sammon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sammon Mapping — riem.sammon","text":"named list containing embed \\((N\\times ndim)\\) matrix whose rows embedded observations. stress discrepancy embedded original distances measure error.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.sammon.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sammon Mapping — riem.sammon","text":"Sammon JW (1969). “Nonlinear Mapping Data Structure Analysis.” IEEE Transactions Computers, C-18(5), 401--409. ISSN 0018-9340.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.sammon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sammon Mapping — riem.sammon","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # 10 perturbed data points near (1,0,0) on S^2 in R^3 # 10 perturbed data points near (0,1,0) on S^2 in R^3 # 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=10)  ## COMPARE SAMMON WITH MDS embed2mds = riem.mds(myriem, ndim=2)$embed embed2sam = riem.sammon(myriem, ndim=2)$embed  ## VISUALIZE opar = par(no.readonly=TRUE) par(mfrow=c(1,2), pty=\"s\") plot(embed2mds, col=mylabs, pch=19, main=\"MDS\") plot(embed2sam, col=mylabs, pch=19, main=\"Sammon mapping\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.sc05Z.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral Clustering by Zelnik-Manor and Perona (2005) — riem.sc05Z","title":"Spectral Clustering by Zelnik-Manor and Perona (2005) — riem.sc05Z","text":"Zelnik-Manor Perona proposed method define set data-driven  bandwidth parameters \\(\\sigma_i\\) distance point \\(x_i\\) nnbd-th  nearest neighbor. affinity matrix defined $$A_{ij} = \\exp(-d(x_i, d_j)^2 / \\sigma_i \\sigma_j)$$ standard  spectral clustering Ng, Jordan, Weiss (riem.scNJW) applied.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.sc05Z.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral Clustering by Zelnik-Manor and Perona (2005) — riem.sc05Z","text":"","code":"riem.sc05Z(riemobj, k = 2, nnbd = 7, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.sc05Z.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral Clustering by Zelnik-Manor and Perona (2005) — riem.sc05Z","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number clusters (default: 2). nnbd neighborhood size define data-driven bandwidth parameter (default: 7). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.sc05Z.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral Clustering by Zelnik-Manor and Perona (2005) — riem.sc05Z","text":"named list containing cluster length-\\(N\\) vector class labels (\\(1:k\\)). eigval eigenvalues graph laplacian's spectral decomposition. embeds \\((N\\times k)\\) low-dimensional embedding.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.sc05Z.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spectral Clustering by Zelnik-Manor and Perona (2005) — riem.sc05Z","text":"Zelnik-manor L, Perona P (2005). \"Self-Tuning Spectral Clustering.\" Saul LK, Weiss Y, Bottou L (eds.), Advances Neural Information Processing Systems 17, 1601–1608. MIT Press.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.sc05Z.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spectral Clustering by Zelnik-Manor and Perona (2005) — riem.sc05Z","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) lab    = rep(c(1,2,3), each=10)  ## CLUSTERING WITH DIFFERENT K VALUES cl2 = riem.sc05Z(myriem, k=2)$cluster cl3 = riem.sc05Z(myriem, k=3)$cluster cl4 = riem.sc05Z(myriem, k=4)$cluster  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,4), pty=\"s\") plot(mds2d, col=lab, pch=19, main=\"true label\") plot(mds2d, col=cl2, pch=19, main=\"riem.sc05Z: k=2\") plot(mds2d, col=cl3, pch=19, main=\"riem.sc05Z: k=3\") plot(mds2d, col=cl4, pch=19, main=\"riem.sc05Z: k=4\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.scNJW.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral Clustering by Ng, Jordan, and Weiss (2002) — riem.scNJW","title":"Spectral Clustering by Ng, Jordan, and Weiss (2002) — riem.scNJW","text":"version Ng, Jordan, Weiss first constructs affinity matrix $$A_{ij} = \\exp(-d(x_i, d_j)^2 / \\sigma^2)$$ \\(\\sigma\\) common bandwidth parameter performs k-means clustering  row-space eigenvectors symmetric graph laplacian matrix $$L=D^{-1/2}(D-)D^{-1/2}$$.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scNJW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral Clustering by Ng, Jordan, and Weiss (2002) — riem.scNJW","text":"","code":"riem.scNJW(riemobj, k = 2, sigma = 1, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.scNJW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral Clustering by Ng, Jordan, and Weiss (2002) — riem.scNJW","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number clusters (default: 2). sigma bandwidth parameter (default: 1). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scNJW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral Clustering by Ng, Jordan, and Weiss (2002) — riem.scNJW","text":"named list containing cluster length-\\(N\\) vector class labels (\\(1:k\\)). eigval eigenvalues graph laplacian's spectral decomposition. embeds \\((N\\times k)\\) low-dimensional embedding.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scNJW.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spectral Clustering by Ng, Jordan, and Weiss (2002) — riem.scNJW","text":"Ng AY, Jordan MI, Weiss Y (2002). \"Spectral Clustering: Analysis Algorithm.\" Dietterich TG, Becker S, Ghahramani Z (eds.), Advances Neural Information Processing Systems 14, 849–856. MIT Press.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scNJW.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spectral Clustering by Ng, Jordan, and Weiss (2002) — riem.scNJW","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) lab    = rep(c(1,2,3), each=10)  ## CLUSTERING WITH DIFFERENT K VALUES cl2 = riem.scNJW(myriem, k=2)$cluster cl3 = riem.scNJW(myriem, k=3)$cluster cl4 = riem.scNJW(myriem, k=4)$cluster  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,4), pty=\"s\") plot(mds2d, col=lab, pch=19, main=\"true label\") plot(mds2d, col=cl2, pch=19, main=\"riem.scNJW: k=2\") plot(mds2d, col=cl3, pch=19, main=\"riem.scNJW: k=3\") plot(mds2d, col=cl4, pch=19, main=\"riem.scNJW: k=4\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.scSM.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral Clustering by Shi and Malik (2000) — riem.scSM","title":"Spectral Clustering by Shi and Malik (2000) — riem.scSM","text":"version Shi Malik first constructs affinity matrix $$A_{ij} = \\exp(-d(x_i, d_j)^2 / \\sigma^2)$$ \\(\\sigma\\) common bandwidth parameter performs k-means clustering  row-space eigenvectors random-walk graph laplacian matrix $$L=D^{-1}(D-)$$.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scSM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral Clustering by Shi and Malik (2000) — riem.scSM","text":"","code":"riem.scSM(riemobj, k = 2, sigma = 1, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.scSM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral Clustering by Shi and Malik (2000) — riem.scSM","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number clusters (default: 2). sigma bandwidth parameter (default: 1). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scSM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral Clustering by Shi and Malik (2000) — riem.scSM","text":"named list containing cluster length-\\(N\\) vector class labels (\\(1:k\\)). eigval eigenvalues graph laplacian's spectral decomposition. embeds \\((N\\times k)\\) low-dimensional embedding.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scSM.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spectral Clustering by Shi and Malik (2000) — riem.scSM","text":"Shi J, Malik J (2000). “Normalized Cuts Image Segmentation.\" IEEE Transactions Pattern Analysis Machine Intelligence, 22(8):888–905.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scSM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spectral Clustering by Shi and Malik (2000) — riem.scSM","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) lab    = rep(c(1,2,3), each=10)  ## CLUSTERING WITH DIFFERENT K VALUES cl2 = riem.scSM(myriem, k=2)$cluster cl3 = riem.scSM(myriem, k=3)$cluster cl4 = riem.scSM(myriem, k=4)$cluster  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,4), pty=\"s\") plot(mds2d, col=lab, pch=19, main=\"true label\") plot(mds2d, col=cl2, pch=19, main=\"riem.scSM: k=2\") plot(mds2d, col=cl3, pch=19, main=\"riem.scSM: k=3\") plot(mds2d, col=cl4, pch=19, main=\"riem.scSM: k=4\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.scUL.html","id":null,"dir":"Reference","previous_headings":"","what":"Spectral Clustering with Unnormalized Laplacian — riem.scUL","title":"Spectral Clustering with Unnormalized Laplacian — riem.scUL","text":"version Shi Malik first constructs affinity matrix $$A_{ij} = \\exp(-d(x_i, d_j)^2 / \\sigma^2)$$ \\(\\sigma\\) common bandwidth parameter performs k-means clustering  row-space eigenvectors unnormalized graph laplacian matrix $$L=D-$$.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scUL.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spectral Clustering with Unnormalized Laplacian — riem.scUL","text":"","code":"riem.scUL(riemobj, k = 2, sigma = 1, geometry = c(\"intrinsic\", \"extrinsic\"))"},{"path":"https://kisungyou.com/Riemann/reference/riem.scUL.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spectral Clustering with Unnormalized Laplacian — riem.scUL","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. k number clusters (default: 2). sigma bandwidth parameter (default: 1). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scUL.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spectral Clustering with Unnormalized Laplacian — riem.scUL","text":"named list containing cluster length-\\(N\\) vector class labels (\\(1:k\\)). eigval eigenvalues graph laplacian's spectral decomposition. embeds \\((N\\times k)\\) low-dimensional embedding.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scUL.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spectral Clustering with Unnormalized Laplacian — riem.scUL","text":"von Luxburg U (2007). “Tutorial Spectral Clustering.” Statistics Computing, 17(4):395–416.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.scUL.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spectral Clustering with Unnormalized Laplacian — riem.scUL","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # class 1 : 10 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 10 perturbed data points near (0,1,0) on S^2 in R^3 # class 3 : 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:10){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 11:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:30){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) lab    = rep(c(1,2,3), each=10)  ## CLUSTERING WITH DIFFERENT K VALUES cl2 = riem.scUL(myriem, k=2)$cluster cl3 = riem.scUL(myriem, k=3)$cluster cl4 = riem.scUL(myriem, k=4)$cluster  ## MDS FOR VISUALIZATION mds2d = riem.mds(myriem, ndim=2)$embed  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,4), pty=\"s\") plot(mds2d, col=lab, pch=19, main=\"true label\") plot(mds2d, col=cl2, pch=19, main=\"riem.scUL: k=2\") plot(mds2d, col=cl3, pch=19, main=\"riem.scUL: k=3\") plot(mds2d, col=cl4, pch=19, main=\"riem.scUL: k=4\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.seb.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the Smallest Enclosing Ball — riem.seb","title":"Find the Smallest Enclosing Ball — riem.seb","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\), find smallest enclosing ball.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.seb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the Smallest Enclosing Ball — riem.seb","text":"","code":"riem.seb(riemobj, method = c(\"aa2013\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/riem.seb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the Smallest Enclosing Ball — riem.seb","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. method (case-insensitive) name algorithm used follows; \"aa2013\" Arnaudon Nielsen (2013). ... extra parameters including maxiter maximum number iterations run (default:50). eps tolerance level stopping criterion (default: 1e-5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.seb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the Smallest Enclosing Ball — riem.seb","text":"named list containing center matrix \\(\\mathcal{M}\\) minimizes radius. radius minimal radius respect center.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.seb.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Find the Smallest Enclosing Ball — riem.seb","text":"Bâdoiu M, Clarkson KL (2003). “Smaller core-sets balls.” Proceedings fourteenth annual ACM-SIAM symposium discrete algorithms,  SODA '03, 801--802. ISBN 0-89871-538-5. Arnaudon M, Nielsen F (2013). “approximating Riemannian 1-center.” Computational Geometry, 46(1), 93--104. ISSN 09257721.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.seb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the Smallest Enclosing Ball — riem.seb","text":"","code":"#------------------------------------------------------------------- #       Euclidean Example : samples from Standard Normal in R^2 #------------------------------------------------------------------- ## GENERATE 25 OBSERVATIONS FROM N(0,I) ndata  = 25 mymats = array(0,c(ndata, 2)) mydata = list() for (i in 1:ndata){   mydata[[i]] = stats::rnorm(2)   mymats[i,]  = mydata[[i]] } myriem = wrap.euclidean(mydata)  ## COMPUTE sebobj = riem.seb(myriem) center = as.vector(sebobj$center)  radius = sebobj$radius  ## VISUALIZE #  1. prepare the circle for drawing theta  = seq(from=0, to=2*pi, length.out=100) coords = radius*cbind(cos(theta), sin(theta)) coords = coords + matrix(rep(center, each=100), ncol=2)  #  2. draw opar <- par(no.readonly=TRUE) par(pty=\"s\") plot(coords, type=\"l\", lwd=2, col=\"red\",      main=\"Euclidean SEB\", xlab=\"x\", ylab=\"y\") points(mymats, pch=19)                           # data points(center[1], center[2], pch=19, col=\"blue\") # center   par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.test2bg14.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-Sample Test modified from Biswas and Ghosh (2014) — riem.test2bg14","title":"Two-Sample Test modified from Biswas and Ghosh (2014) — riem.test2bg14","text":"Given \\(M\\) observations \\(X_1, X_2, \\ldots, X_M \\\\mathcal{M}\\)  \\(N\\) observations \\(Y_1, Y_2, \\ldots, Y_N \\\\mathcal{M}\\), perform permutation test equal distribution $$H_0~:~\\mathcal{P}_X = \\mathcal{P}_Y$$ method Biswas Ghosh (2014). method, originally proposed  Euclidean-valued data, adapted general Riemannian manifold  intrinsic/extrinsic distance.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.test2bg14.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Two-Sample Test modified from Biswas and Ghosh (2014) — riem.test2bg14","text":"","code":"riem.test2bg14(riemobj1, riemobj2, geometry = c(\"intrinsic\", \"extrinsic\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/riem.test2bg14.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Two-Sample Test modified from Biswas and Ghosh (2014) — riem.test2bg14","text":"riemobj1 S3 \"riemdata\" class \\(M\\) manifold-valued data. riemobj2 S3 \"riemdata\" class \\(N\\) manifold-valued data. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including nperm number permutations (default: 999).","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.test2bg14.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Two-Sample Test modified from Biswas and Ghosh (2014) — riem.test2bg14","text":"(list) object S3 class htest containing: statistic test statistic. p.value \\(p\\)-value \\(H_0\\). alternative alternative hypothesis. method name test. data.name name(s) provided sample data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.test2bg14.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Two-Sample Test modified from Biswas and Ghosh (2014) — riem.test2bg14","text":"Biswas M, Ghosh AK (2014). “nonparametric two-sample test applicable high dimensional data.” Journal Multivariate Analysis, 123, 160--171. ISSN 0047259X. K, Park H (2020). “Re-visiting Riemannian geometry symmetric positive definite matrices analysis functional connectivity.” NeuroImage, 117464. ISSN 10538119.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.test2bg14.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Two-Sample Test modified from Biswas and Ghosh (2014) — riem.test2bg14","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with two types # # class 1 : 20 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 30 perturbed data points near (0,1,0) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata1 = list() mydata2 = list() for (i in 1:20){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata1[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 1:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata2[[i]] = tgt/sqrt(sum(tgt^2)) } myriem1 = wrap.sphere(mydata1) myriem2 = wrap.sphere(mydata2)  ## PERFORM PERMUTATION TEST #  it is expected to return a very small number. # \\donttest{ riem.test2bg14(myriem1, myriem2, nperm=999) #>  #> \tTwo-Sample Test on Sphere as of Biswas and Ghosh (2014) #>  #> data:  'myriem1' and 'myriem2' #> Tmn = 3.6793, p-value = 0.001 #> alternative hypothesis: two distributions are not equal. #>  # }  if (FALSE) { ## CHECK WITH EMPIRICAL TYPE-1 ERROR set.seed(777) ntest = 1000 pvals = rep(0,ntest)  for (i in 1:ntest){   X = cbind(matrix(rnorm(30*2, sd=0.1),ncol=2), rep(1,30))   Y = cbind(matrix(rnorm(30*2, sd=0.1),ncol=2), rep(1,30))   Xnorm = X/sqrt(rowSums(X^2))   Ynorm = Y/sqrt(rowSums(Y^2))      Xriem = wrap.sphere(Xnorm)   Yriem = wrap.sphere(Ynorm)   pvals[i] = riem.test2bg14(Xriem, Yriem, nperm=999)$p.value }  emperr = round(sum((pvals <= 0.05))/ntest, 5) print(paste0(\"* EMPIRICAL TYPE-1 ERROR=\", emperr)) }"},{"path":"https://kisungyou.com/Riemann/reference/riem.test2wass.html","id":null,"dir":"Reference","previous_headings":"","what":"Two-Sample Test with Wasserstein Metric — riem.test2wass","title":"Two-Sample Test with Wasserstein Metric — riem.test2wass","text":"Given \\(M\\) observations \\(X_1, X_2, \\ldots, X_M \\\\mathcal{M}\\)  \\(N\\) observations \\(Y_1, Y_2, \\ldots, Y_N \\\\mathcal{M}\\), permutation  test based Wasserstein metric (see riem.wasserstein  details) applied test whether two distributions , .e., $$H_0~:~\\mathcal{P}_X = \\mathcal{P}_Y$$ Wasserstein metric \\(\\mathcal{W}_p\\) measure discrepancy  two samples.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.test2wass.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Two-Sample Test with Wasserstein Metric — riem.test2wass","text":"","code":"riem.test2wass(   riemobj1,   riemobj2,   p = 2,   geometry = c(\"intrinsic\", \"extrinsic\"),   ... )"},{"path":"https://kisungyou.com/Riemann/reference/riem.test2wass.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Two-Sample Test with Wasserstein Metric — riem.test2wass","text":"riemobj1 S3 \"riemdata\" class \\(M\\) manifold-valued data. riemobj2 S3 \"riemdata\" class \\(N\\) manifold-valued data. p exponent Wasserstein distance \\(\\mathcal{W}_p\\) (default: 2). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including nperm number permutations (default: 999). use.smooth logical; TRUE use smoothed Wasserstein distance, FALSE otherwise.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.test2wass.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Two-Sample Test with Wasserstein Metric — riem.test2wass","text":"(list) object S3 class htest containing: statistic test statistic. p.value \\(p\\)-value \\(H_0\\). alternative alternative hypothesis. method name test. data.name name(s) provided sample data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.test2wass.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Two-Sample Test with Wasserstein Metric — riem.test2wass","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with two types # # class 1 : 20 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 30 perturbed data points near (0,1,0) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata1 = list() mydata2 = list() for (i in 1:20){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata1[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 1:20){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata2[[i]] = tgt/sqrt(sum(tgt^2)) } myriem1 = wrap.sphere(mydata1) myriem2 = wrap.sphere(mydata2)  ## PERFORM PERMUTATION TEST #  it is expected to return a very small number, but  #  small number of 'nperm' may not give a reasonable p-value. # \\donttest{ riem.test2wass(myriem1, myriem2, nperm=99, use.smooth=FALSE) #>  #> \tWasserstein Two-Sample Test on Sphere Manifold #>  #> data:  'myriem1' and 'myriem2' #> Wmn = 1.5712, p-value = 0.01 #> alternative hypothesis: two distributions are not equal. #>  # }  if (FALSE) { ## CHECK WITH EMPIRICAL TYPE-1 ERROR set.seed(777) ntest = 1000 pvals = rep(0,ntest)  for (i in 1:ntest){   X = cbind(matrix(rnorm(30*2, sd=0.1),ncol=2), rep(1,30))   Y = cbind(matrix(rnorm(30*2, sd=0.1),ncol=2), rep(1,30))   Xnorm = X/sqrt(rowSums(X^2))   Ynorm = Y/sqrt(rowSums(Y^2))      Xriem = wrap.sphere(Xnorm)   Yriem = wrap.sphere(Ynorm)   pvals[i] = riem.test2wass(Xriem, Yriem, nperm=999)$p.value   print(paste0(\"iteration \",i,\"/\",ntest,\" complete..\")) }  emperr = round(sum((pvals <= 0.05))/ntest, 5) print(paste0(\"* EMPIRICAL TYPE-1 ERROR=\", emperr)) }"},{"path":"https://kisungyou.com/Riemann/reference/riem.tsne.html","id":null,"dir":"Reference","previous_headings":"","what":"t-distributed Stochastic Neighbor Embedding — riem.tsne","title":"t-distributed Stochastic Neighbor Embedding — riem.tsne","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N \\\\mathcal{M}\\),  t-SNE mimicks pattern probability distributions pairs manifold-valued  objects low-dimensional target embedding space minimizing Kullback-Leibler divergence.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.tsne.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"t-distributed Stochastic Neighbor Embedding — riem.tsne","text":"","code":"riem.tsne(riemobj, ndim = 2, geometry = c(\"intrinsic\", \"extrinsic\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/riem.tsne.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"t-distributed Stochastic Neighbor Embedding — riem.tsne","text":"riemobj S3 \"riemdata\" class \\(N\\) manifold-valued data. ndim integer-valued target dimension. geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters Rtsne algorithm Rtsne package, perplexity, momentum, others.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.tsne.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"t-distributed Stochastic Neighbor Embedding — riem.tsne","text":"named list containing embed \\((N\\times ndim)\\) matrix whose rows embedded observations. stress discrepancy embedded original distances measure error.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.tsne.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"t-distributed Stochastic Neighbor Embedding — riem.tsne","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with three types # # 10 perturbed data points near (1,0,0) on S^2 in R^3 # 10 perturbed data points near (0,1,0) on S^2 in R^3 # 10 perturbed data points near (0,0,1) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata = list() for (i in 1:20){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 21:40){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 41:60){   tgt = c(stats::rnorm(2, sd=0.1), 1)   mydata[[i]] = tgt/sqrt(sum(tgt^2)) } myriem = wrap.sphere(mydata) mylabs = rep(c(1,2,3), each=20)  ## RUN THE ALGORITHM IN TWO GEOMETRIES mypx = 5 embed2int = riem.tsne(myriem, ndim=2, geometry=\"intrinsic\", perplexity=mypx) embed2ext = riem.tsne(myriem, ndim=2, geometry=\"extrinsic\", perplexity=mypx)  ## VISUALIZE opar = par(no.readonly=TRUE) par(mfrow=c(1,2), pty=\"s\") plot(embed2int$embed, main=\"intrinsic t-SNE\", col=mylabs, pch=19) plot(embed2ext$embed, main=\"extrinsic t-SNE\", col=mylabs, pch=19)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/riem.wasserstein.html","id":null,"dir":"Reference","previous_headings":"","what":"Wasserstein Distance between Empirical Measures — riem.wasserstein","title":"Wasserstein Distance between Empirical Measures — riem.wasserstein","text":"Given two empirical measures \\(\\mu, \\nu\\) consisting \\(M\\) \\(N\\) observations, \\(p\\)-Wasserstein distance \\(p\\geq 1\\) two empirical measures  defined  $$\\mathcal{W}_p (\\mu, \\nu) = \\left( \\inf_{\\gamma \\\\Gamma(\\mu, \\nu)} \\int_{\\mathcal{M}\\times \\mathcal{M}} d(x,y)^p d \\gamma(x,y) \\right)^{1/p}$$ \\(\\Gamma(\\mu, \\nu)\\) denotes collection measures/couplings \\(\\mathcal{M}\\times \\mathcal{M}\\)  whose marginals \\(\\mu\\) \\(\\nu\\) first second factors, respectively.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.wasserstein.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wasserstein Distance between Empirical Measures — riem.wasserstein","text":"","code":"riem.wasserstein(   riemobj1,   riemobj2,   p = 2,   geometry = c(\"intrinsic\", \"extrinsic\"),   ... )"},{"path":"https://kisungyou.com/Riemann/reference/riem.wasserstein.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wasserstein Distance between Empirical Measures — riem.wasserstein","text":"riemobj1 S3 \"riemdata\" class \\(M\\) manifold-valued data, atoms \\(\\mu\\). riemobj2 S3 \"riemdata\" class \\(N\\) manifold-valued data, atoms \\(\\nu\\). p exponent Wasserstein distance \\(\\mathcal{W}_p\\) (default: 2). geometry (case-insensitive) name geometry; either geodesic (\"intrinsic\") embedded (\"extrinsic\") geometry. ... extra parameters including weight1 length-\\(M\\) weight vector \\(\\mu\\); NULL (default), uniform weight set. weight2 length-\\(N\\) weight vector \\(\\nu\\); NULL (default), uniform weight set.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.wasserstein.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wasserstein Distance between Empirical Measures — riem.wasserstein","text":"named list containing distance \\(\\mathcal{W_p}\\) distance two empirical measures. plan \\((M\\times N)\\) matrix whose rowSums columnSums weight1 weight2 respectively.","code":""},{"path":"https://kisungyou.com/Riemann/reference/riem.wasserstein.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wasserstein Distance between Empirical Measures — riem.wasserstein","text":"","code":"#------------------------------------------------------------------- #          Example on Sphere : a dataset with two types # # class 1 : 20 perturbed data points near (1,0,0) on S^2 in R^3 # class 2 : 30 perturbed data points near (0,1,0) on S^2 in R^3 #------------------------------------------------------------------- ## GENERATE DATA mydata1 = list() mydata2 = list() for (i in 1:20){   tgt = c(1, stats::rnorm(2, sd=0.1))   mydata1[[i]] = tgt/sqrt(sum(tgt^2)) } for (i in 1:30){   tgt = c(rnorm(1,sd=0.1),1,rnorm(1,sd=0.1))   mydata2[[i]] = tgt/sqrt(sum(tgt^2)) } myriem1 = wrap.sphere(mydata1) myriem2 = wrap.sphere(mydata2)  ## COMPUTE p-WASSERSTEIN DISTANCES dist1 = riem.wasserstein(myriem1, myriem2, p=1) dist2 = riem.wasserstein(myriem1, myriem2, p=2) dist5 = riem.wasserstein(myriem1, myriem2, p=5)  pm1 = paste0(\"p=1: dist=\",round(dist1$distance,3)) pm2 = paste0(\"p=2: dist=\",round(dist2$distance,3)) pm5 = paste0(\"p=5: dist=\",round(dist5$distance,3))  ## VISUALIZE TRANSPORT PLAN AND DISTANCE opar <- par(no.readonly=TRUE) par(mfrow=c(1,3)) image(dist1$plan, axes=FALSE, main=pm1) image(dist2$plan, axes=FALSE, main=pm2) image(dist5$plan, axes=FALSE, main=pm5)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/rmvnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Random Samples from Multivariate Normal Distribution — rmvnorm","title":"Generate Random Samples from Multivariate Normal Distribution — rmvnorm","text":"\\(\\mathbf{R}^p\\), random samples drawn $$X_1,X_2,\\ldots,X_n~ \\sim ~ \\mathcal{N}(\\mu, \\Sigma)$$ \\(\\mu \\\\mathbf{R}^p\\) mean vector \\(\\Sigma \\\\textrm{SPD}(p)\\)  positive definite covariance matrix.","code":""},{"path":"https://kisungyou.com/Riemann/reference/rmvnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Random Samples from Multivariate Normal Distribution — rmvnorm","text":"","code":"rmvnorm(n = 1, mu, sigma)"},{"path":"https://kisungyou.com/Riemann/reference/rmvnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Random Samples from Multivariate Normal Distribution — rmvnorm","text":"n number samples generated. mu mean vector. sigma covariance matrix.","code":""},{"path":"https://kisungyou.com/Riemann/reference/rmvnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Random Samples from Multivariate Normal Distribution — rmvnorm","text":"either (1) length-\\(p\\) vector (\\(n=1\\)) (2) \\((n\\times p)\\) matrix rows random samples.","code":""},{"path":"https://kisungyou.com/Riemann/reference/rmvnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Random Samples from Multivariate Normal Distribution — rmvnorm","text":"","code":"#------------------------------------------------------------------- #   Generate Random Data and Compare with Empirical Covariances # # In R^5 with zero mean and diagonal covariance,  # generate 100 and 200 observations and compute MLE covariance. #------------------------------------------------------------------- ## GENERATE DATA mymu  = rep(0,5) mysig = diag(5)  ## MLE FOR COVARIANCE smat1 = stats::cov(rmvnorm(n=100, mymu, mysig)) smat2 = stats::cov(rmvnorm(n=200, mymu, mysig))  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,3), pty=\"s\") image(mysig[,5:1], axes=FALSE, main=\"true covariance\") image(smat1[,5:1], axes=FALSE, main=\"empirical cov with n=100\") image(smat2[,5:1], axes=FALSE, main=\"empirical cov with n=200\")  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/spd.geometry.html","id":null,"dir":"Reference","previous_headings":"","what":"Supported Geometries on SPD Manifold — spd.geometry","title":"Supported Geometries on SPD Manifold — spd.geometry","text":"SPD manifold well-studied space many geometries  proposed space. special functions SPD category,  function finds whether exists matching name currently  supported Riemann. none, return error message.","code":""},{"path":"https://kisungyou.com/Riemann/reference/spd.geometry.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Supported Geometries on SPD Manifold — spd.geometry","text":"","code":"spd.geometry(geometry)"},{"path":"https://kisungyou.com/Riemann/reference/spd.geometry.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Supported Geometries on SPD Manifold — spd.geometry","text":"geometry name supported geometries, including AIRM Affine-Invariant Riemannian Metric. LERM Log-Euclidean Riemannian Metric. Jeffrey Jeffrey's divergence. Stein Stein's metric. Wasserstein 2-Wasserstein geometry.","code":""},{"path":"https://kisungyou.com/Riemann/reference/spd.geometry.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Supported Geometries on SPD Manifold — spd.geometry","text":"matching name lower-case.","code":""},{"path":"https://kisungyou.com/Riemann/reference/spd.geometry.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Supported Geometries on SPD Manifold — spd.geometry","text":"","code":"# it just returns a small-letter string. mygeom = spd.geometry(\"stein\")"},{"path":"https://kisungyou.com/Riemann/reference/spd.pdist.html","id":null,"dir":"Reference","previous_headings":"","what":"Pairwise Distance on SPD Manifold — spd.pdist","title":"Pairwise Distance on SPD Manifold — spd.pdist","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N\\) SPD manifold, compute  pairwise distances among observations.","code":""},{"path":"https://kisungyou.com/Riemann/reference/spd.pdist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pairwise Distance on SPD Manifold — spd.pdist","text":"","code":"spd.pdist(spdobj, geometry, as.dist = FALSE)"},{"path":"https://kisungyou.com/Riemann/reference/spd.pdist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pairwise Distance on SPD Manifold — spd.pdist","text":"spdobj S3 \"riemdata\" class SPD-valued data. geometry name geometry used. See spd.geometry supported geometries. .dist logical; TRUE, returns dist object. Else, returns symmetric matrix.","code":""},{"path":"https://kisungyou.com/Riemann/reference/spd.pdist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pairwise Distance on SPD Manifold — spd.pdist","text":"S3 dist object \\((N\\times N)\\) symmetric matrix pairwise distances according .dist parameter.","code":""},{"path":"https://kisungyou.com/Riemann/reference/spd.pdist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pairwise Distance on SPD Manifold — spd.pdist","text":"","code":"# \\donttest{ #------------------------------------------------------------------- #                   Two Types of Covariances # #  group1 : perturbed from data by N(0,1) in R^3 #  group2 : perturbed from data by [sin(x); cos(x); sin(x)*cos(x)] #------------------------------------------------------------------- ## GENERATE DATA spd_mats = array(0,c(3,3,20)) for (i in 1:10){   spd_mats[,,i] = stats::cov(matrix(rnorm(50*3), ncol=3)) } for (j in 11:20){   randvec = stats::rnorm(50, sd=3)   randmat = cbind(sin(randvec), cos(randvec), sin(randvec)*cos(randvec))   spd_mats[,,j] = stats::cov(randmat + matrix(rnorm(50*3, sd=0.1), ncol=3)) }  ## WRAP IT AS SPD OBJECT spd_obj = wrap.spd(spd_mats)  ## COMPUTE PAIRWISE DISTANCES #  Geometries are case-insensitive. pdA = spd.pdist(spd_obj, \"airM\") pdL = spd.pdist(spd_obj, \"lErm\") pdJ = spd.pdist(spd_obj, \"Jeffrey\") pdS = spd.pdist(spd_obj, \"stEin\") pdW = spd.pdist(spd_obj, \"wasserstein\")  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(2,3), pty=\"s\") image(pdA, axes=FALSE, main=\"AIRM\") image(pdL, axes=FALSE, main=\"LERM\") image(pdJ, axes=FALSE, main=\"Jeffrey\") image(pdS, axes=FALSE, main=\"Stein\") image(pdW, axes=FALSE, main=\"Wasserstein\") par(opar)  # }"},{"path":"https://kisungyou.com/Riemann/reference/spd.wassbary.html","id":null,"dir":"Reference","previous_headings":"","what":"Wasserstein Barycenter of SPD Matrices — spd.wassbary","title":"Wasserstein Barycenter of SPD Matrices — spd.wassbary","text":"Given \\(N\\) observations \\(X_1, X_2, \\ldots, X_N\\) SPD manifold, compute  \\(L_2\\)-Wasserstein barycenter minimizes $$\\sum_{n=1}^N \\lambda_i \\mathcal{W}_2 (N(X), N(X_i))^2$$ \\(N(X)\\) denotes zero-mean Gaussian measure covariance \\(X\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/spd.wassbary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wasserstein Barycenter of SPD Matrices — spd.wassbary","text":"","code":"spd.wassbary(spdobj, weight = NULL, method = c(\"RU02\", \"AE16\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/spd.wassbary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wasserstein Barycenter of SPD Matrices — spd.wassbary","text":"spdobj S3 \"riemdata\" class SPD-valued data \\((p\\times p)\\) matrices. weight weight observations; NULL assumes equal weights, nonnegative length-\\(N\\) vector sums 1 given. method name algortihm used; one \"RU02\", \"AE16\". ... extra parameters including maxiter maximum number iterations run (default:20). abstol tolerance level stopping criterion (default: 1e-8).","code":""},{"path":"https://kisungyou.com/Riemann/reference/spd.wassbary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wasserstein Barycenter of SPD Matrices — spd.wassbary","text":"\\((p\\times p)\\) Wasserstein barycenter matrix.","code":""},{"path":"https://kisungyou.com/Riemann/reference/spd.wassbary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wasserstein Barycenter of SPD Matrices — spd.wassbary","text":"","code":"# \\donttest{ #------------------------------------------------------------------- #        Covariances from standard multivariate Gaussians. #------------------------------------------------------------------- ## GENERATE DATA ndata = 20 pdim  = 10 mydat = array(0,c(pdim,pdim,ndata)) for (i in 1:ndata){   mydat[,,i] = stats::cov(matrix(rnorm(100*pdim), ncol=pdim)) } myriem = wrap.spd(mydat)  ## COMPUTE BY DIFFERENT ALGORITHMS baryRU <- spd.wassbary(myriem, method=\"RU02\") baryAE <- spd.wassbary(myriem, method=\"AE16\")  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,3), pty=\"s\") image(diag(pdim), axes=FALSE, main=\"True Covariance\") image(baryRU, axes=FALSE, main=\"by RU02\") image(baryAE, axes=FALSE, main=\"by AE16\")  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/sphere.convert.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between Cartesian Coordinates and Geographic Coordinates — sphere.convert","title":"Convert between Cartesian Coordinates and Geographic Coordinates — sphere.convert","text":"geospatial data analysis, common consider locations Earth  data. locations, usually provided latitude longitude, directly  applicable spherical data analysis. provide two functions - sphere.geo2xyz sphere.xyz2geo -  convert geographic coordinates longitude/latitude unit-norm vector \\(\\mathcal{S}^2\\), vice versa.  convention, latitude longitude represented decimal degrees.","code":""},{"path":"https://kisungyou.com/Riemann/reference/sphere.convert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between Cartesian Coordinates and Geographic Coordinates — sphere.convert","text":"","code":"sphere.geo2xyz(lat, lon)  sphere.xyz2geo(xyz)"},{"path":"https://kisungyou.com/Riemann/reference/sphere.convert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between Cartesian Coordinates and Geographic Coordinates — sphere.convert","text":"lat latitude (decimal degrees). lon longitude (decimal degrees). xyz unit-norm vector \\(\\mathcal{S}^{2}\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/sphere.convert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between Cartesian Coordinates and Geographic Coordinates — sphere.convert","text":"transformed data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/sphere.convert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between Cartesian Coordinates and Geographic Coordinates — sphere.convert","text":"","code":"## EXAMPLE DATA WITH POPULATED US CITIES data(cities)  ## SELECT ALBUQUERQUE geo = cities$coord[1,] xyz = cities$cartesian[1,]  ## CHECK TWO INPUT TYPES AND THEIR CONVERSIONS sphere.geo2xyz(geo[1], geo[2]) #> [1] -0.2339521 -0.7837773  0.5752908 sphere.xyz2geo(xyz) #> [1]   35.12 -106.62"},{"path":"https://kisungyou.com/Riemann/reference/sphere.runif.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Uniform Samples on Sphere — sphere.runif","title":"Generate Uniform Samples on Sphere — sphere.runif","text":"generates \\(n\\) random samples \\(\\mathcal{S}^{p-1}\\). convenient  usage users, provide number options terms return type.","code":""},{"path":"https://kisungyou.com/Riemann/reference/sphere.runif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Uniform Samples on Sphere — sphere.runif","text":"","code":"sphere.runif(n, p, type = c(\"list\", \"matrix\", \"riemdata\"))"},{"path":"https://kisungyou.com/Riemann/reference/sphere.runif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Uniform Samples on Sphere — sphere.runif","text":"n number samples generated. p original dimension (ambient space). type return type; \"list\" length-\\(n\\) list length-\\(p\\) vectors. \"matrix\" \\((n\\times p)\\) rows unit vectors. \"riemdata\" S3 object. See wrap.sphere details (Default).","code":""},{"path":"https://kisungyou.com/Riemann/reference/sphere.runif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Uniform Samples on Sphere — sphere.runif","text":"object one type option.","code":""},{"path":"https://kisungyou.com/Riemann/reference/sphere.runif.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Uniform Samples on Sphere — sphere.runif","text":"Chikuse Y (2003). Statistics Special Manifolds, volume 174 Lecture Notes Statistics. Springer New York, New York, NY. ISBN 978-0-387-00160-9 978-0-387-21540-2.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/sphere.runif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Uniform Samples on Sphere — sphere.runif","text":"","code":"#------------------------------------------------------------------- #                       Draw Samples on Sphere # # Multiple return types on S^4 in R^5 #------------------------------------------------------------------- dat.list = sphere.runif(n=10, p=5, type=\"list\") dat.matx = sphere.runif(n=10, p=5, type=\"matrix\") dat.riem = sphere.runif(n=10, p=5, type=\"riemdata\")"},{"path":"https://kisungyou.com/Riemann/reference/sphere.utest.html","id":null,"dir":"Reference","previous_headings":"","what":"Test of Uniformity on Sphere — sphere.utest","title":"Test of Uniformity on Sphere — sphere.utest","text":"Given \\(N\\) observations \\(\\lbrace X_1, X_2, \\ldots, X_M \\brace\\)  \\(\\mathcal{S}^{p-1}\\), tests whether data distributed uniformly  sphere.","code":""},{"path":"https://kisungyou.com/Riemann/reference/sphere.utest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test of Uniformity on Sphere — sphere.utest","text":"","code":"sphere.utest(spobj, method = c(\"Rayleigh\", \"RayleighM\"))"},{"path":"https://kisungyou.com/Riemann/reference/sphere.utest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test of Uniformity on Sphere — sphere.utest","text":"spobj S3 \"riemdata\" class \\(N\\) Sphere-valued data. method (case-insensitive) name test method containing \"Rayleigh\" original Rayleigh statistic. \"RayleighM\" modified Rayleigh statistic better order error.","code":""},{"path":"https://kisungyou.com/Riemann/reference/sphere.utest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test of Uniformity on Sphere — sphere.utest","text":"(list) object S3 class htest containing: statistic test statistic. p.value \\(p\\)-value \\(H_0\\). alternative alternative hypothesis. method name test. data.name name(s) provided sample data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/sphere.utest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Test of Uniformity on Sphere — sphere.utest","text":"Chikuse Y (2003). Statistics Special Manifolds, volume 174 Lecture Notes Statistics. Springer New York, New York, NY. ISBN 978-0-387-00160-9 978-0-387-21540-2. Mardia KV, Jupp PE (eds.) (1999). Directional Statistics,  Wiley Series Probability Statistics. John Wiley \\& Sons, Inc., Hoboken, NJ, USA. ISBN 978-0-470-31697-9 978-0-471-95333-3.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/sphere.utest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test of Uniformity on Sphere — sphere.utest","text":"","code":"#------------------------------------------------------------------- #   Compare Rayleigh's original and modified versions of the test #------------------------------------------------------------------- #  Data Generation myobj = sphere.runif(n=100, p=5, type=\"riemdata\")  #  Compare 2 versions : Original vs Modified Rayleigh sphere.utest(myobj, method=\"rayleigh\") #>  #> \tRayleigh Test of Uniformity on Sphere #>  #> data:  myobj #> statistic = 2.2526, p-value = 0.8132 #> alternative hypothesis: data is not uniformly distributed on 4-sphere. #>  sphere.utest(myobj, method=\"rayleighm\") #>  #> \tModified Rayleigh Test of Uniformity on Sphere #>  #> data:  myobj #> statistic = 2.2449, p-value = 0.8143 #> alternative hypothesis: data is not uniformly distributed on 4-sphere. #>"},{"path":"https://kisungyou.com/Riemann/reference/splaplace.html","id":null,"dir":"Reference","previous_headings":"","what":"Spherical Laplace Distribution — splaplace","title":"Spherical Laplace Distribution — splaplace","text":"collection tools learning spherical Laplace (SL) distribution  \\((p-1)\\)-dimensional sphere \\(\\mathbf{R}^p\\) including sampling, density evaluation,  maximum likelihood estimation parameters. SL distribution characterized following  density function, $$f_{SL}(x; \\mu, \\sigma) = \\frac{1}{C(\\sigma)} \\exp \\left( -\\frac{d(x,\\mu)}{\\sigma}  \\right)$$ location scale parameters \\(\\mu\\) \\(\\sigma\\) respectively.","code":""},{"path":"https://kisungyou.com/Riemann/reference/splaplace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spherical Laplace Distribution — splaplace","text":"","code":"dsplaplace(data, mu, sigma, log = FALSE)  rsplaplace(n, mu, sigma)  mle.splaplace(data, method = c(\"DE\", \"Optimize\", \"Newton\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/splaplace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spherical Laplace Distribution — splaplace","text":"data data vectors form either \\((n\\times p)\\) matrix length-\\(n\\) list.  See wrap.sphere descriptions supported input types. mu length-\\(p\\) unit-norm vector location. sigma scale parameter positive. log logical; TRUE return log-density, FALSE densities without logarithm applied. n number samples generated. method algorithm name concentration parameter estimation. one \"Newton\", \"Optimize\", \"DE\" (case-sensitive). ... extra parameters computations, including maxiter maximum number iterations run (default:50). eps tolerance level stopping criterion (default: 1e-6). use.exact logical use exact (TRUE) approximate (FALSE) updating rules (default: FALSE).","code":""},{"path":"https://kisungyou.com/Riemann/reference/splaplace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spherical Laplace Distribution — splaplace","text":"dsplaplace gives vector evaluated densities given samples. rsplaplace generates  unit-norm vectors \\(\\mathbf{R}^p\\) wrapped list. mle.splaplace computes MLEs returns list  containing estimates location (mu) scale (sigma) parameters.","code":""},{"path":"https://kisungyou.com/Riemann/reference/splaplace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spherical Laplace Distribution — splaplace","text":"","code":"# \\donttest{ # ------------------------------------------------------------------- #          Example with Spherical Laplace Distribution # # Given a fixed set of parameters, generate samples and acquire MLEs. # Especially, we will see the evolution of estimation accuracy. # ------------------------------------------------------------------- ## DEFAULT PARAMETERS true.mu  = c(1,0,0,0,0) true.sig = 1  ## GENERATE A RANDOM SAMPLE OF SIZE N=1000 big.data = rsplaplace(1000, true.mu, true.sig)  ## ITERATE FROM 50 TO 1000 by 10 idseq = seq(from=50, to=1000, by=10) nseq  = length(idseq)  hist.mu  = rep(0, nseq) hist.sig = rep(0, nseq)  for (i in 1:nseq){   small.data = big.data[1:idseq[i]]             # data subsetting   small.MLE  = mle.splaplace(small.data)        # compute MLE      hist.mu[i]  = acos(sum(small.MLE$mu*true.mu)) # difference in mu   hist.sig[i] = small.MLE$sigma }  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,2)) plot(idseq, hist.mu,  \"b\", pch=19, cex=0.5,       main=\"difference in location\", xlab=\"sample size\") plot(idseq, hist.sig, \"b\", pch=19, cex=0.5,       main=\"scale parameter\", xlab=\"sample size\") abline(h=true.sig, lwd=2, col=\"red\")  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/spnorm.html","id":null,"dir":"Reference","previous_headings":"","what":"Spherical Normal Distribution — spnorm","title":"Spherical Normal Distribution — spnorm","text":"provide tools isotropic spherical normal (SN) distributions  \\((p-1)\\)-sphere \\(\\mathbf{R}^p\\) sampling, density evaluation, maximum likelihood estimation  parameters density defined $$f_{SN}(x; \\mu, \\lambda) = \\frac{1}{Z(\\lambda)} \\exp \\left( -\\frac{\\lambda}{2} d^2(x,\\mu) \\right)$$ location concentration parameters \\(\\mu\\) \\(\\lambda\\) respectively normalizing constant \\(Z(\\lambda)\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/spnorm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Spherical Normal Distribution — spnorm","text":"","code":"dspnorm(data, mu, lambda, log = FALSE)  rspnorm(n, mu, lambda)  mle.spnorm(data, method = c(\"Newton\", \"Halley\", \"Optimize\", \"DE\"), ...)"},{"path":"https://kisungyou.com/Riemann/reference/spnorm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Spherical Normal Distribution — spnorm","text":"data data vectors form either \\((n\\times p)\\) matrix length-\\(n\\) list.  See wrap.sphere descriptions supported input types. mu length-\\(p\\) unit-norm vector location. lambda concentration parameter positive. log logical; TRUE return log-density, FALSE densities without logarithm applied. n number samples generated. method algorithm name concentration parameter estimation. one \"Newton\",\"Halley\",\"Optimize\", \"DE\" (case sensitive). ... extra parameters computations, including maxiter maximum number iterations run (default:50). eps tolerance level stopping criterion (default: 1e-5).","code":""},{"path":"https://kisungyou.com/Riemann/reference/spnorm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Spherical Normal Distribution — spnorm","text":"dspnorm gives vector evaluated densities given samples. rspnorm generates  unit-norm vectors \\(\\mathbf{R}^p\\) wrapped list. mle.spnorm computes MLEs returns list  containing estimates location (mu) concentration (lambda) parameters.","code":""},{"path":"https://kisungyou.com/Riemann/reference/spnorm.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Spherical Normal Distribution — spnorm","text":"Hauberg S (2018). “Directional Statistics Spherical Normal Distribution.” 2018 21st International Conference Information Fusion (FUSION), 704--711. ISBN 978-0-9964527-6-2. K, Suh C (2022). “Parameter Estimation Model-Based Clustering Spherical Normal Distribution Unit Hypersphere.” Computational Statistics \\& Data Analysis, 107457. ISSN 01679473.","code":""},{"path":"https://kisungyou.com/Riemann/reference/spnorm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Spherical Normal Distribution — spnorm","text":"","code":"# \\donttest{ # ------------------------------------------------------------------- #          Example with Spherical Normal Distribution # # Given a fixed set of parameters, generate samples and acquire MLEs. # Especially, we will see the evolution of estimation accuracy. # ------------------------------------------------------------------- ## DEFAULT PARAMETERS true.mu  = c(1,0,0,0,0) true.lbd = 5  ## GENERATE DATA N=1000 big.data = rspnorm(1000, true.mu, true.lbd)  ## ITERATE FROM 50 TO 1000 by 10 idseq = seq(from=50, to=1000, by=10) nseq  = length(idseq)  hist.mu  = rep(0, nseq) hist.lbd = rep(0, nseq)  for (i in 1:nseq){   small.data = big.data[1:idseq[i]]          # data subsetting   small.MLE  = mle.spnorm(small.data) # compute MLE      hist.mu[i]  = acos(sum(small.MLE$mu*true.mu)) # difference in mu   hist.lbd[i] = small.MLE$lambda }  ## VISUALIZE opar <- par(no.readonly=TRUE) par(mfrow=c(1,2)) plot(idseq, hist.mu,  \"b\", pch=19, cex=0.5, main=\"difference in location\") plot(idseq, hist.lbd, \"b\", pch=19, cex=0.5, main=\"concentration param\") abline(h=true.lbd, lwd=2, col=\"red\")  par(opar) # }"},{"path":"https://kisungyou.com/Riemann/reference/stiefel.optSA.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Annealing on Stiefel Manifold — stiefel.optSA","title":"Simulated Annealing on Stiefel Manifold — stiefel.optSA","text":"Simulated Annealing black-box, derivative-free optimization algorithm  iterates via stochastic search neighborhood current position.  stiefel.optSA solves following problem $$\\min_X f(X),\\quad X \\St(p,k)$$ without auxiliary information gradient hessian involved.","code":""},{"path":"https://kisungyou.com/Riemann/reference/stiefel.optSA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Annealing on Stiefel Manifold — stiefel.optSA","text":"","code":"stiefel.optSA(func, p, k, ...)"},{"path":"https://kisungyou.com/Riemann/reference/stiefel.optSA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulated Annealing on Stiefel Manifold — stiefel.optSA","text":"func function minimized. p dimension parameter \\(St(k,p)\\). k dimension parameter \\(St(k,p)\\). ... extra parameters SA algorithm including n.start number runs; algorithm executed n.start times (default: 5). stepsize size random walk component (default: 0.1). maxiter maximum number iterations run (default: 100). cooling triplet cooling schedule. See section usage. init.val NULL, starts random point. Otherwise, Stiefel matrix size \\((p,k)\\) provided fixed starting point. print.progress logical; TRUE, prints iteration.","code":""},{"path":"https://kisungyou.com/Riemann/reference/stiefel.optSA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulated Annealing on Stiefel Manifold — stiefel.optSA","text":"named list containing: cost minimized function value. solution \\((p\\times k)\\) matrix attains cost. accfreq frequency acceptance moves.","code":""},{"path":"https://kisungyou.com/Riemann/reference/stiefel.optSA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulated Annealing on Stiefel Manifold — stiefel.optSA","text":"","code":"#------------------------------------------------------------------- #               Optimization for Eigen-Decomposition # # Given (5x5) covariance matrix S, eigendecomposition is indeed  # an optimization problem cast on the stiefel manifold. Here,  # we are trying to find top 3 eigenvalues and compare. #------------------------------------------------------------------- ## PREPARE set.seed(121)                         # set seed A = cov(matrix(rnorm(100*5), ncol=5)) # define covariance myfunc <- function(p){                # cost function to minimize   return(sum(-diag(t(p)%*%A%*%p))) }   ## SOLVE THE OPTIMIZATION PROBLEM Aout = stiefel.optSA(myfunc, p=5, k=3, n.start=40, maxiter=200)  ## COMPUTE EIGENVALUES #  1. USE SOLUTIONS TO THE ABOVE OPTIMIZATION  abase   = Aout$solution eig3sol = sort(diag(t(abase)%*%A%*%abase), decreasing=TRUE)  #  2. USE BASIC 'EIGEN' FUNCTION eig3dec = sort(eigen(A)$values, decreasing=TRUE)[1:3]  ## VISUALIZE opar <- par(no.readonly=TRUE) yran = c(min(min(eig3sol),min(eig3dec))*0.95,          max(max(eig3sol),max(eig3dec))*1.05) plot(1:3, eig3sol, type=\"b\", col=\"red\",  pch=19, ylim=yran,      xlab=\"index\", ylab=\"eigenvalue\", main=\"compare top 3 eigenvalues\") lines(1:3, eig3dec, type=\"b\", col=\"blue\", pch=19) legend(1, 1, legend=c(\"optimization\",\"decomposition\"), col=c(\"red\",\"blue\"),        lty=rep(1,2), pch=19)  par(opar)"},{"path":"https://kisungyou.com/Riemann/reference/stiefel.runif.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Uniform Samples on Stiefel Manifold — stiefel.runif","title":"Generate Uniform Samples on Stiefel Manifold — stiefel.runif","text":"generates \\(n\\) random samples Stiefel manifold \\(St(k,p)\\).","code":""},{"path":"https://kisungyou.com/Riemann/reference/stiefel.runif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Uniform Samples on Stiefel Manifold — stiefel.runif","text":"","code":"stiefel.runif(n, k, p, type = c(\"list\", \"array\", \"riemdata\"))"},{"path":"https://kisungyou.com/Riemann/reference/stiefel.runif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Uniform Samples on Stiefel Manifold — stiefel.runif","text":"n number samples generated. k dimension frame. p original dimension (ambient space). type return type; \"list\" length-\\(n\\) list \\((p\\times k)\\) basis \\(k\\)-frames. \"array\" \\((p\\times k\\times n)\\) 3D array whose slices \\(k\\)-frame basis. \"riemdata\" S3 object. See wrap.stiefel details.","code":""},{"path":"https://kisungyou.com/Riemann/reference/stiefel.runif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Uniform Samples on Stiefel Manifold — stiefel.runif","text":"object one type option.","code":""},{"path":"https://kisungyou.com/Riemann/reference/stiefel.runif.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate Uniform Samples on Stiefel Manifold — stiefel.runif","text":"Chikuse Y (2003). Statistics Special Manifolds, volume 174 Lecture Notes Statistics. Springer New York, New York, NY. ISBN 978-0-387-00160-9 978-0-387-21540-2.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/stiefel.runif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Uniform Samples on Stiefel Manifold — stiefel.runif","text":"","code":"#------------------------------------------------------------------- #                 Draw Samples on Stiefel Manifold  # # Try Different Return Types with 3 Observations of 5-frames in R^10 #------------------------------------------------------------------- #  GENERATION dat.list = stiefel.runif(n=3, k=5, p=10, type=\"list\") dat.arr3 = stiefel.runif(n=3, k=5, p=10, type=\"array\") dat.riem = stiefel.runif(n=3, k=5, p=10, type=\"riemdata\")"},{"path":"https://kisungyou.com/Riemann/reference/stiefel.utest.html","id":null,"dir":"Reference","previous_headings":"","what":"Test of Uniformity on Stiefel Manifold — stiefel.utest","title":"Test of Uniformity on Stiefel Manifold — stiefel.utest","text":"Given data Stiefel manifold \\(St(k,p)\\), tests whether  data distributed uniformly.","code":""},{"path":"https://kisungyou.com/Riemann/reference/stiefel.utest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test of Uniformity on Stiefel Manifold — stiefel.utest","text":"","code":"stiefel.utest(stobj, method = c(\"Rayleigh\", \"RayleighM\"))"},{"path":"https://kisungyou.com/Riemann/reference/stiefel.utest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test of Uniformity on Stiefel Manifold — stiefel.utest","text":"stobj S3 \"riemdata\" class \\(N\\) Stiefel-valued data. method (case-insensitive) name test method containing \"Rayleigh\" original Rayleigh statistic. \"RayleighM\" modified Rayleigh statistic better order error.","code":""},{"path":"https://kisungyou.com/Riemann/reference/stiefel.utest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test of Uniformity on Stiefel Manifold — stiefel.utest","text":"(list) object S3 class htest containing: statistic test statistic. p.value \\(p\\)-value \\(H_0\\). alternative alternative hypothesis. method name test. data.name name(s) provided sample data.","code":""},{"path":"https://kisungyou.com/Riemann/reference/stiefel.utest.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Test of Uniformity on Stiefel Manifold — stiefel.utest","text":"Chikuse Y (2003). Statistics Special Manifolds, volume 174 Lecture Notes Statistics. Springer New York, New York, NY. ISBN 978-0-387-00160-9 978-0-387-21540-2. Mardia KV, Jupp PE (eds.) (1999). Directional Statistics,  Wiley Series Probability Statistics. John Wiley \\& Sons, Inc., Hoboken, NJ, USA. ISBN 978-0-470-31697-9 978-0-471-95333-3.","code":""},{"path":[]},{"path":"https://kisungyou.com/Riemann/reference/stiefel.utest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test of Uniformity on Stiefel Manifold — stiefel.utest","text":"","code":"#------------------------------------------------------------------- #   Compare Rayleigh's original and modified versions of the test #  # Test 1. sample uniformly from St(2,4) # Test 2. use perturbed principal components from 'iris' data in R^4 #         which is concentrated around a point to reject H0. #------------------------------------------------------------------- ## DATA GENERATION #  1. uniform data myobj1 = stiefel.runif(n=100, k=2, p=4)  #  2. perturbed principal components data(iris) irdat = list() for (n in 1:100){    tmpdata    = iris[1:50,1:4] + matrix(rnorm(50*4,sd=0.5),ncol=4)    irdat[[n]] = eigen(cov(tmpdata))$vectors[,1:2] } myobj2 = wrap.stiefel(irdat)  ## TEST #  1. uniform data stiefel.utest(myobj1, method=\"Rayleigh\") #>  #> \tRayleigh Test of Uniformity on Stiefel Manifold #>  #> data:  myobj1 #> statistic = 9.5223, p-value = 0.3002 #> alternative hypothesis: data is not uniformly distributed on St(2,4). #>  stiefel.utest(myobj1, method=\"RayleighM\") #>  #> \tModified Rayleigh Test of Uniformity on Stiefel Manifold #>  #> data:  myobj1 #> statistic = 9.5201, p-value = 0.3003 #> alternative hypothesis: data is not uniformly distributed on St(2,4). #>   #  2. concentrated data stiefel.utest(myobj2, method=\"rayleIgh\")   # method names are  #>  #> \tRayleigh Test of Uniformity on Stiefel Manifold #>  #> data:  myobj2 #> statistic = 67.364, p-value = 1.642e-11 #> alternative hypothesis: data is not uniformly distributed on St(2,4). #>  stiefel.utest(myobj2, method=\"raYleiGhM\")  # CASE - INSENSITIVE ! #>  #> \tModified Rayleigh Test of Uniformity on Stiefel Manifold #>  #> data:  myobj2 #> statistic = 69.296, p-value = 6.786e-12 #> alternative hypothesis: data is not uniformly distributed on St(2,4). #>"},{"path":"https://kisungyou.com/Riemann/reference/wrap.correlation.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data on Correlation Manifold — wrap.correlation","title":"Prepare Data on Correlation Manifold — wrap.correlation","text":"collection correlation matrices considered subset (quotient)  well-known SPD manifold. package, defined $$\\mathcal{C}_{++}^p = \\lbrace X \\\\mathbf{R}^{p\\times p} ~\\vert~ X^\\top = X,~ \\textrm{rank}(X)=p,~ \\textrm{diag}(X) = 1 \\rbrace$$ rank condition means strictly positive definite. Please note  geometry involving semi-definite correlation matrices objective .","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.correlation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data on Correlation Manifold — wrap.correlation","text":"","code":"wrap.correlation(input)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.correlation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data on Correlation Manifold — wrap.correlation","text":"input correlation data matrices wrapped riemdata class. Following inputs considered, array \\((p\\times p\\times n)\\) array slice along 3rd dimension correlation matrix. list length-\\(n\\) list whose elements \\((p\\times p)\\) correlation matrices.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.correlation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data on Correlation Manifold — wrap.correlation","text":"named riemdata S3 object containing data list \\((p\\times p)\\) correlation matrices. size size correlation matrix. name name manifold interests, \"correlation\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.correlation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Data on Correlation Manifold — wrap.correlation","text":"","code":"#------------------------------------------------------------------- #                 Checker for Two Types of Inputs # #  5 observations; empirical correlation of normal observations. #------------------------------------------------------------------- #  Data Generation d1 = array(0,c(3,3,5)) d2 = list() for (i in 1:5){   dat = matrix(rnorm(10*3),ncol=3)   d1[,,i] = stats::cor(dat)   d2[[i]] = d1[,,i] }  #  Run test1 = wrap.correlation(d1) test2 = wrap.correlation(d2)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.euclidean.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data on Euclidean Space — wrap.euclidean","title":"Prepare Data on Euclidean Space — wrap.euclidean","text":"Euclidean space \\(\\mathbf{R}^p\\) common space data analysis,  can considered Riemannian manifold flat metric. Since space matrices isomorphic Euclidean space vectorization,  consider inputs \\(p\\)-dimensional vectors.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.euclidean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data on Euclidean Space — wrap.euclidean","text":"","code":"wrap.euclidean(input)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.euclidean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data on Euclidean Space — wrap.euclidean","text":"input data vectors wrapped riemdata class. Following inputs considered, matrix \\((n \\times p)\\) matrix row observations. list length-\\(n\\) list whose elements length-\\(p\\) vectors.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.euclidean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data on Euclidean Space — wrap.euclidean","text":"named riemdata S3 object containing data list \\((p\\times 1)\\) matrices \\(\\mathbf{R}^p\\). size dimension ambient space. name name manifold interests, \"euclidean\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.euclidean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Data on Euclidean Space — wrap.euclidean","text":"","code":"#------------------------------------------------------------------- #                 Checker for Two Types of Inputs # #  Generate 5 observations in R^3 in Matrix and List. #------------------------------------------------------------------- ## DATA GENERATION d1 = array(0,c(5,3)) d2 = list() for (i in 1:5){   single  = stats::rnorm(3)   d1[i,]  = single   d2[[i]] = single }  ## RUN test1 = wrap.euclidean(d1) test2 = wrap.euclidean(d2)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.grassmann.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data on Grassmann Manifold — wrap.grassmann","title":"Prepare Data on Grassmann Manifold — wrap.grassmann","text":"Grassmann manifold \\(Gr(k,p)\\) set \\(k\\)-planes, \\(k\\)-dimensional subspaces \\(R^p\\),  means given matrix \\(Y \\\\mathbf{R}{p\\times k}\\), column space \\(SPAN(Y)\\) element  Grassmann manifold. use convention element \\(Gr(k,p)\\) represented orthonormal basis (ONB) \\(X \\\\mathbf{R}^{p\\times k}\\) $$X^\\top X = I_k.$$ provided form, wrapper takes QR decomposition given data  recover corresponding ONB.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.grassmann.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data on Grassmann Manifold — wrap.grassmann","text":"","code":"wrap.grassmann(input)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.grassmann.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data on Grassmann Manifold — wrap.grassmann","text":"input data matrices wrapped riemdata class. Following inputs considered, array \\((p\\times k\\times n)\\) array slice along 3rd dimension \\(k\\)-subspace basis dimension \\(p\\). list length-\\(n\\) list whose elements \\((p\\times k)\\) basis \\(k\\)-subspace.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.grassmann.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data on Grassmann Manifold — wrap.grassmann","text":"named riemdata S3 object containing data list k-subspace basis matrices. size size k-subspace basis matrix. name name manifold interests, \"grassmann\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.grassmann.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Data on Grassmann Manifold — wrap.grassmann","text":"","code":"#------------------------------------------------------------------- #                 Checker for Two Types of Inputs # #  Generate 5 observations in Gr(2,4) #------------------------------------------------------------------- #  Generation d1 = array(0,c(4,2,5)) d2 = list() for (i in 1:5){   d1[,,i] = matrix(rnorm(4*2), ncol=2)   d2[[i]] = d1[,,i] }  #  Run test1 = wrap.grassmann(d1) test2 = wrap.grassmann(d2)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.landmark.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrap Landmark Data on Shape Space — wrap.landmark","title":"Wrap Landmark Data on Shape Space — wrap.landmark","text":"One frameworks used shape space represent data landmarks.  shape point set \\(k\\) points \\(\\mathbf{R}^p\\)  point labeled object. consider general landmarks \\(p=2,3,\\ldots\\).  Note \\(p > 2\\), stratified space assume singularities exist  omitted. wrapper takes translation scaling data make  preshape (centered, unit-norm). Also, convenience, orthogonal  Procrustes analysis applied first observation reference  data rotated match shape first.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.landmark.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrap Landmark Data on Shape Space — wrap.landmark","text":"","code":"wrap.landmark(input)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.landmark.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrap Landmark Data on Shape Space — wrap.landmark","text":"input data matrices wrapped riemdata class. Following inputs considered, array \\((k\\times p\\times n)\\) array slice along 3rd dimension \\(k\\)-ad \\(\\mathbf{R}^p\\). list length-\\(n\\) list whose elements \\(k\\)-ads.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.landmark.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrap Landmark Data on Shape Space — wrap.landmark","text":"named riemdata S3 object containing data list preshapes \\(\\mathbf{R}^p\\). size size preshape. name name manifold interests, \"landmark\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.landmark.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Wrap Landmark Data on Shape Space — wrap.landmark","text":"Dryden IL, Mardia KV (2016). Statistical shape analysis applications R,  Wiley series probability statistics, Second edition edition. John Wiley \\& Sons, Chichester, UK ; Hoboken, NJ. ISBN 978-1-119-07251-5 978-1-119-07250-8.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.landmark.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrap Landmark Data on Shape Space — wrap.landmark","text":"","code":"## USE 'GORILLA' DATA data(gorilla) riemobj = wrap.landmark(gorilla$male)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.multinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data on Multinomial Manifold — wrap.multinomial","title":"Prepare Data on Multinomial Manifold — wrap.multinomial","text":"Multinomial manifold referred data nonnegative sums 1.  Also known probability simplex positive orthant, denote \\((p-1)\\) simplex  \\(\\mathbf{R}^p\\)  $$\\Delta^{p-1} = \\lbrace x \\\\mathbf{R}^p~\\vert~ \\sum_{=1}^p x_i = 1, x_i > 0 \\rbrace$$ data positive \\(L_1\\) unit-norm vectors.  wrap.multinomial, normalization applied data point simplex,  vectors contain values \\((0,1)\\), returns errors.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.multinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data on Multinomial Manifold — wrap.multinomial","text":"","code":"wrap.multinomial(input)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.multinomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data on Multinomial Manifold — wrap.multinomial","text":"input data vectors wrapped riemdata class. Following inputs considered, matrix \\((n \\times p)\\) matrix row observations. list length-\\(n\\) list whose elements length-\\(p\\) vectors.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.multinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data on Multinomial Manifold — wrap.multinomial","text":"named riemdata S3 object containing data list \\((p\\times 1)\\) matrices \\(\\Delta^{p-1}\\). size dimension ambient space. name name manifold interests, \"multinomial\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.multinomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Data on Multinomial Manifold — wrap.multinomial","text":"","code":"#------------------------------------------------------------------- #                 Checker for Two Types of Inputs #------------------------------------------------------------------- ## DATA GENERATION d1 = array(0,c(5,3)) d2 = list() for (i in 1:5){   single  = abs(stats::rnorm(3))   d1[i,]  = single   d2[[i]] = single }  ## RUN test1 = wrap.multinomial(d1) test2 = wrap.multinomial(d2)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.rotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data on Rotation Group — wrap.rotation","title":"Prepare Data on Rotation Group — wrap.rotation","text":"Rotation group, also known special orthogonal group, Riemannian  manifold $$(p) = \\lbrace Q \\\\mathbf{R}^{p\\times p}~\\vert~ Q^\\top Q = , \\textrm{det}(Q)=1 \\rbrace $$ name originates observation \\(p=2,3\\) matrices rotation  shapes/configurations.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.rotation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data on Rotation Group — wrap.rotation","text":"","code":"wrap.rotation(input)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.rotation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data on Rotation Group — wrap.rotation","text":"input data matrices wrapped riemdata class. Following inputs considered, array \\((p\\times p\\times n)\\) array slice along 3rd dimension rotation matrix. list length-\\(n\\) list whose elements \\((p\\times p)\\) rotation matrices.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.rotation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data on Rotation Group — wrap.rotation","text":"named riemdata S3 object containing data list \\((p\\times p)\\) rotation matrices. size size rotation matrix. name name manifold interests, \"rotation\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.rotation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Data on Rotation Group — wrap.rotation","text":"","code":"#------------------------------------------------------------------- #                 Checker for Two Types of Inputs #------------------------------------------------------------------- ## DATA GENERATION d1 = array(0,c(3,3,5)) d2 = list() for (i in 1:5){   single  = qr.Q(qr(matrix(rnorm(9),nrow=3)))   d1[,,i] = single   d2[[i]] = single }  ## RUN test1 = wrap.rotation(d1) test2 = wrap.rotation(d2)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.spd.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data on Symmetric Positive-Definite (SPD) Manifold — wrap.spd","title":"Prepare Data on Symmetric Positive-Definite (SPD) Manifold — wrap.spd","text":"collection symmetric positive-definite matrices well-known example  matrix manifold. defined $$\\mathcal{S}_{++}^p = \\lbrace X \\\\mathbf{R}^{p\\times p} ~\\vert~ X^\\top = X,~ \\textrm{rank}(X)=p \\rbrace$$ rank condition means strictly positive definite. Please note  geometry involving semi-definite matrices considered wrap.spdk.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.spd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data on Symmetric Positive-Definite (SPD) Manifold — wrap.spd","text":"","code":"wrap.spd(input)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.spd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data on Symmetric Positive-Definite (SPD) Manifold — wrap.spd","text":"input SPD data matrices wrapped riemdata class. Following inputs considered, array \\((p\\times p\\times n)\\) array slice along 3rd dimension SPD matrix. list length-\\(n\\) list whose elements \\((p\\times p)\\) SPD matrices.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.spd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data on Symmetric Positive-Definite (SPD) Manifold — wrap.spd","text":"named riemdata S3 object containing data list \\((p\\times p)\\) SPD matrices. size size SPD matrix. name name manifold interests, \"spd\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.spd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Data on Symmetric Positive-Definite (SPD) Manifold — wrap.spd","text":"","code":"#------------------------------------------------------------------- #                 Checker for Two Types of Inputs # #  Generate 5 observations; empirical covariance of normal observations. #------------------------------------------------------------------- #  Data Generation d1 = array(0,c(3,3,5)) d2 = list() for (i in 1:5){   dat = matrix(rnorm(10*3),ncol=3)   d1[,,i] = stats::cov(dat)   d2[[i]] = d1[,,i] }  #  Run test1 = wrap.spd(d1) test2 = wrap.spd(d2)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.spdk.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data on SPD Manifold of Fixed-Rank — wrap.spdk","title":"Prepare Data on SPD Manifold of Fixed-Rank — wrap.spdk","text":"\\((p\\times p)\\) SPD matrices fixed-rank \\(k < p\\), form  geometric structure represented \\((p\\times k)\\) matrices, $$SPD(k,p) = \\lbrace X \\\\mathbf{R}^{(p\\times p)}~\\vert~ Y Y^\\top = X, \\textrm{rank}(X) = k \\rbrace$$ key difference \\(\\mathcal{S}_{++}^p\\) matrices  fixed rank \\(k\\) \\(k\\) usually smaller \\(p\\). Inputs  given \\((p\\times p)\\) matrices specified \\(k\\) wrap.spdk  automatically decomposes input square matrices rank-\\(k\\) representation matrices.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.spdk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data on SPD Manifold of Fixed-Rank — wrap.spdk","text":"","code":"wrap.spdk(input, k)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.spdk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data on SPD Manifold of Fixed-Rank — wrap.spdk","text":"input data matrices wrapped riemdata class. Following inputs considered, array \\((p\\times p\\times n)\\) array slice along 3rd dimension rank-\\(k\\) matrix. list length-\\(n\\) list whose elements \\((p\\times p)\\) matrices rank-\\(k\\). k rank SPD matrices.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.spdk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data on SPD Manifold of Fixed-Rank — wrap.spdk","text":"named riemdata S3 object containing data list \\((p\\times k)\\) representation corresponding rank-\\(k\\) SPSD matrices. size size representation matrix. name name manifold interests, \"spdk\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.spdk.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Prepare Data on SPD Manifold of Fixed-Rank — wrap.spdk","text":"Journée M, Bach F, Absil P, Sepulchre R (2010). “Low-rank optimization cone positive semidefinite matrices.” SIAM Journal Optimization, 20(5), 2327--2351.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.spdk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Data on SPD Manifold of Fixed-Rank — wrap.spdk","text":"","code":"#------------------------------------------------------------------- #                 Checker for Two Types of Inputs #------------------------------------------------------------------- #  Data Generation d1 = array(0,c(10,10,3)) d2 = list() for (i in 1:3){   dat = matrix(rnorm(10*10),ncol=10)   d1[,,i] = stats::cov(dat)   d2[[i]] = d1[,,i] }  #  Run test1 = wrap.spdk(d1, k=2) test2 = wrap.spdk(d2, k=2)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.sphere.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data on Sphere — wrap.sphere","title":"Prepare Data on Sphere — wrap.sphere","text":"unit hypersphere (sphere, short) one fundamental curved  space studying geometry. Precisely, denote \\((p-1)\\) sphere \\(\\mathbf{R}^p\\) $$\\mathcal{S}^{p-1} = \\lbrace x \\\\mathbf{R}^p ~ \\vert ~ x^\\top x = \\|x\\|^2 = 1 \\rbrace$$ vectors unit norm. wrap.sphere, normalization applied  data point unit sphere.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.sphere.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data on Sphere — wrap.sphere","text":"","code":"wrap.sphere(input)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.sphere.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data on Sphere — wrap.sphere","text":"input data vectors wrapped riemdata class. Following inputs considered, matrix \\((n \\times p)\\) matrix row observations unit norm. list length-\\(n\\) list whose elements length-\\(p\\) vectors unit norm.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.sphere.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data on Sphere — wrap.sphere","text":"named riemdata S3 object containing data list \\((p\\times 1)\\) matrices \\(\\mathcal{S}^{p-1}\\). size dimension ambient space. name name manifold interests, \"sphere\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.sphere.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Data on Sphere — wrap.sphere","text":"","code":"#------------------------------------------------------------------- #                 Checker for Two Types of Inputs # #  Generate 5 observations in S^2 embedded in R^3. #------------------------------------------------------------------- ## DATA GENERATION d1 = array(0,c(5,3)) d2 = list() for (i in 1:5){   single  = stats::rnorm(3)   d1[i,]  = single   d2[[i]] = single }  ## RUN test1 = wrap.sphere(d1) test2 = wrap.sphere(d2)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.stiefel.html","id":null,"dir":"Reference","previous_headings":"","what":"Prepare Data on (Compact) Stiefel Manifold — wrap.stiefel","title":"Prepare Data on (Compact) Stiefel Manifold — wrap.stiefel","text":"Stiefel manifold \\(St(k,p)\\) set \\(k\\)-frames \\(\\mathbf{R}^p\\),  indeed Riemannian manifold. usage Riemann package,  data point represented matrix convention $$St(k,p) = \\lbrace X \\\\mathbf{R}^{p\\times k} ~\\vert~ X^\\top X = I_k \\rbrace$$ means columns orthonormal. provided matrix  orthonormal basis , wrap.stiefel applies orthogonalization  extract valid basis information.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.stiefel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prepare Data on (Compact) Stiefel Manifold — wrap.stiefel","text":"","code":"wrap.stiefel(input)"},{"path":"https://kisungyou.com/Riemann/reference/wrap.stiefel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prepare Data on (Compact) Stiefel Manifold — wrap.stiefel","text":"input data matrices wrapped riemdata class. Following inputs considered, array \\((p\\times k\\times n)\\) array slice along 3rd dimension \\(k\\)-frame. list length-\\(n\\) list whose elements \\((p\\times k)\\) \\(k\\)-frames.","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.stiefel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prepare Data on (Compact) Stiefel Manifold — wrap.stiefel","text":"named riemdata S3 object containing data list \\(k\\)-frame orthonormal matrices. size size \\(k\\)-frame basis matrix. name name manifold interests, \"stiefel\"","code":""},{"path":"https://kisungyou.com/Riemann/reference/wrap.stiefel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prepare Data on (Compact) Stiefel Manifold — wrap.stiefel","text":"","code":"#------------------------------------------------------------------- #                 Checker for Two Types of Inputs # #  Generate 5 observations in St(2,4) #------------------------------------------------------------------- #  Data Generation by QR Decomposition d1 = array(0,c(4,2,5)) d2 = list() for (i in 1:5){   d1[,,i] = qr.Q(qr(matrix(rnorm(4*2),ncol=2)))   d2[[i]] = d1[,,i] }  #  Run test1 = wrap.stiefel(d1) test2 = wrap.stiefel(d2)"},{"path":"https://kisungyou.com/Riemann/news/index.html","id":"riemann-014","dir":"Changelog","previous_headings":"","what":"Riemann 0.1.4","title":"Riemann 0.1.4","text":"CRAN release: 2022-02-28 Two mixture models unit hypersphere added. Supports spherical Laplace distribution added. riem.phate() added sub-manifold learning/visualization. New data EEG ERPs available data(ERP). spd.wassbary() added compute Wasserstein barycenter Gaussian distributions.","code":""},{"path":"https://kisungyou.com/Riemann/news/index.html","id":"riemann-013","dir":"Changelog","previous_headings":"","what":"Riemann 0.1.3","title":"Riemann 0.1.3","text":"CRAN release: 2021-06-20 Modified mle.spnorm() controls user-defined stopping criteria. Fixed log-likelihood evaluation mixspnorm().","code":""},{"path":"https://kisungyou.com/Riemann/news/index.html","id":"riemann-012","dir":"Changelog","previous_headings":"","what":"Riemann 0.1.2","title":"Riemann 0.1.2","text":"Added riem.m2skreg() manifold--scalar kernel regression riem.m2skregCV() parameter selection using cross validation.","code":""},{"path":"https://kisungyou.com/Riemann/news/index.html","id":"riemann-011","dir":"Changelog","previous_headings":"","what":"Riemann 0.1.1","title":"Riemann 0.1.1","text":"CRAN release: 2021-05-05 Interfaces functions simplified emphasize key parameters users. Added functionalities added galore. Vignette elementary usage package added.","code":""},{"path":"https://kisungyou.com/Riemann/news/index.html","id":"riemann-010","dir":"Changelog","previous_headings":"","what":"Riemann 0.1.0","title":"Riemann 0.1.0","text":"CRAN release: 2020-09-22 Added NEWS.md file track changes package. Initial release : Hello, World!","code":""}]
